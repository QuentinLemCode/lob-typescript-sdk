/* tslint:disable */
/* eslint-disable */
/**
 * Lob
 * The Lob API is organized around REST. Our API is designed to have predictable, resource-oriented URLs and uses HTTP response codes to indicate any API errors. <p> Looking for our [previous documentation](https://lob.github.io/legacy-docs/)?
 *
 * The version of the OpenAPI document: 1.3.0
 * Contact: lob-openapi@lob.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface Address
 */
export interface Address {
  /**
   * Unique identifier prefixed with `adr_`.
   * @type {string}
   * @memberof Address
   */
  id?: string;
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof Address
   */
  description?: string | null;
  /**
   * Either `name` or `company` is required, you may also add both. Must be no longer than 40 characters. If both `name` and `company` are provided, they will be printed on two separate lines above the rest of the address.
   * @type {string}
   * @memberof Address
   */
  name?: string | null;
  /**
   * Either `name` or `company` is required, you may also add both. Must be no longer than 40 characters. If both `name` and `company` are provided, they will be printed on two separate lines above the rest of the address. This field can be used for any secondary recipient information which is not part of the actual mailing address (Company Name, Department, Attention Line, etc).
   * @type {string}
   * @memberof Address
   */
  company?: string | null;
  /**
   * Must be no longer than 40 characters.
   * @type {string}
   * @memberof Address
   */
  phone?: string | null;
  /**
   * Must be no longer than 100 characters.
   * @type {string}
   * @memberof Address
   */
  email?: string | null;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof Address
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {string}
   * @memberof Address
   */
  address_line1?: string;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  address_line2?: string | null;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  address_city?: string;
  /**
   * 2 letter state short-name code
   * @type {string}
   * @memberof Address
   */
  address_state?: string;
  /**
   * Must follow the ZIP format of `12345` or ZIP+4 format of `12345-1234`.
   * @type {string}
   * @memberof Address
   */
  address_zip?: string;
  /**
   *
   * @type {CountryExtendedExpanded}
   * @memberof Address
   */
  address_country?: CountryExtendedExpanded;
  /**
   *
   * @type {string}
   * @memberof Address
   */
  object?: AddressObjectEnum;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof Address
   */
  date_created?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was last modified.
   * @type {string}
   * @memberof Address
   */
  date_modified?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof Address
   */
  deleted?: boolean;
  /**
   * Only returned for accounts on certain <a href=\"https://dashboard.lob.com/#/settings/editions\">Print &amp; Mail Editions</a>. Value is `true` if the address was altered because the recipient filed for a <a href=\"#ncoa\">National Change of Address (NCOA)</a>, `false` if the NCOA check was run but no altered address was found, and `null` if the NCOA check was not run. The NCOA check does not happen for non-US addresses, for non-deliverable US addresses, or for addresses created before the NCOA feature was added to your account.
   * @type {boolean}
   * @memberof Address
   */
  recipient_moved?: boolean | null;
}

/**
 * @export
 * @enum {string}
 */
export enum AddressObjectEnum {
  Address = "address",
}

/**
 * Lob uses RESTful HTTP response codes to indicate success or failure of an API request. In general, 2xx indicates success, 4xx indicate an input error, and 5xx indicates an error on Lob\'s end.
 * @export
 * @interface AddressDeletion
 */
export interface AddressDeletion {
  /**
   * Unique identifier prefixed with `adr_`.
   * @type {string}
   * @memberof AddressDeletion
   */
  id?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof AddressDeletion
   */
  deleted?: boolean;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof AddressDeletion
   */
  object?: AddressDeletionObjectEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum AddressDeletionObjectEnum {
  AddressDeleted = "address_deleted",
}

/**
 *
 * @export
 * @interface AddressDomestic
 */
export interface AddressDomestic {
  /**
   * The building number, street name, street suffix, and any street directionals. For US addresses, the max length is 64 characters.
   * @type {string}
   * @memberof AddressDomestic
   */
  address_line1?: string;
  /**
   * The suite or apartment number of the recipient address, if applicable. For US addresses, the max length is 64 characters.
   * @type {string}
   * @memberof AddressDomestic
   */
  address_line2?: string | null;
  /**
   *
   * @type {string}
   * @memberof AddressDomestic
   */
  address_city?: string | null;
  /**
   *
   * @type {string}
   * @memberof AddressDomestic
   */
  address_state?: string | null;
  /**
   * Optional postal code. For US addresses, must be either 5 or 9 digits.
   * @type {string}
   * @memberof AddressDomestic
   */
  address_zip?: string | null;
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof AddressDomestic
   */
  description?: string | null;
  /**
   * Either `name` or `company` is required, you may also add both. Must be no longer than 40 characters. If both `name` and `company` are provided, they will be printed on two separate lines above the rest of the address.
   * @type {string}
   * @memberof AddressDomestic
   */
  name?: string | null;
  /**
   * Either `name` or `company` is required, you may also add both. Must be no longer than 40 characters. If both `name` and `company` are provided, they will be printed on two separate lines above the rest of the address. This field can be used for any secondary recipient information which is not part of the actual mailing address (Company Name, Department, Attention Line, etc).
   * @type {string}
   * @memberof AddressDomestic
   */
  company?: string | null;
  /**
   * Must be no longer than 40 characters.
   * @type {string}
   * @memberof AddressDomestic
   */
  phone?: string | null;
  /**
   * Must be no longer than 100 characters.
   * @type {string}
   * @memberof AddressDomestic
   */
  email?: string | null;
  /**
   * The country associated with this address.
   * @type {string}
   * @memberof AddressDomestic
   */
  address_country?: string;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof AddressDomestic
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface AddressDomesticExpanded
 */
export interface AddressDomesticExpanded {
  /**
   * The building number, street name, street suffix, and any street directionals. For US addresses, the max length is 64 characters.
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  address_line1?: string;
  /**
   * The suite or apartment number of the recipient address, if applicable. For US addresses, the max length is 64 characters.
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  address_line2?: string | null;
  /**
   *
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  address_city?: string | null;
  /**
   *
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  address_state?: string | null;
  /**
   * Optional postal code. For US addresses, must be either 5 or 9 digits.
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  address_zip?: string | null;
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  description?: string | null;
  /**
   * Either `name` or `company` is required, you may also add both. Must be no longer than 40 characters. If both `name` and `company` are provided, they will be printed on two separate lines above the rest of the address.
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  name?: string | null;
  /**
   * Either `name` or `company` is required, you may also add both. Must be no longer than 40 characters. If both `name` and `company` are provided, they will be printed on two separate lines above the rest of the address. This field can be used for any secondary recipient information which is not part of the actual mailing address (Company Name, Department, Attention Line, etc).
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  company?: string | null;
  /**
   * Must be no longer than 40 characters.
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  phone?: string | null;
  /**
   * Must be no longer than 100 characters.
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  email?: string | null;
  /**
   * The country associated with this address.
   * @type {string}
   * @memberof AddressDomesticExpanded
   */
  address_country?: string;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof AddressDomesticExpanded
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface AddressEditable
 */
export interface AddressEditable {
  /**
   * The building number, street name, street suffix, and any street directionals. For US addresses, the max length is 64 characters.
   * @type {string}
   * @memberof AddressEditable
   */
  address_line1?: string;
  /**
   * The suite or apartment number of the recipient address, if applicable. For US addresses, the max length is 64 characters.
   * @type {string}
   * @memberof AddressEditable
   */
  address_line2?: string | null;
  /**
   *
   * @type {string}
   * @memberof AddressEditable
   */
  address_city?: string | null;
  /**
   *
   * @type {string}
   * @memberof AddressEditable
   */
  address_state?: string | null;
  /**
   * Optional postal code. For US addresses, must be either 5 or 9 digits.
   * @type {string}
   * @memberof AddressEditable
   */
  address_zip?: string | null;
  /**
   *
   * @type {CountryExtended}
   * @memberof AddressEditable
   */
  address_country?: CountryExtended;
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof AddressEditable
   */
  description?: string | null;
  /**
   * Either `name` or `company` is required, you may also add both. Must be no longer than 40 characters. If both `name` and `company` are provided, they will be printed on two separate lines above the rest of the address.
   * @type {string}
   * @memberof AddressEditable
   */
  name?: string | null;
  /**
   * Either `name` or `company` is required, you may also add both. Must be no longer than 40 characters. If both `name` and `company` are provided, they will be printed on two separate lines above the rest of the address. This field can be used for any secondary recipient information which is not part of the actual mailing address (Company Name, Department, Attention Line, etc).
   * @type {string}
   * @memberof AddressEditable
   */
  company?: string | null;
  /**
   * Must be no longer than 40 characters.
   * @type {string}
   * @memberof AddressEditable
   */
  phone?: string | null;
  /**
   * Must be no longer than 100 characters.
   * @type {string}
   * @memberof AddressEditable
   */
  email?: string | null;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof AddressEditable
   */
  metadata?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface AddressList
 */
export interface AddressList {
  /**
   * list of addresses
   * @type {Array<Address>}
   * @memberof AddressList
   */
  data?: Array<Address>;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof AddressList
   */
  object?: string;
  /**
   * Url of next page of items in list.
   * @type {string}
   * @memberof AddressList
   */
  next_url?: string | null;
  /**
   * Url of previous page of items in list.
   * @type {string}
   * @memberof AddressList
   */
  previous_url?: string | null;
  /**
   * number of resources in a set
   * @type {number}
   * @memberof AddressList
   */
  count?: number;
}
/**
 *
 * @export
 * @interface BankAccount
 */
export interface BankAccount {
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof BankAccount
   */
  description?: string | null;
  /**
   * Must be a [valid US routing number](https://www.frbservices.org/index.html).
   * @type {string}
   * @memberof BankAccount
   */
  routing_number?: string;
  /**
   *
   * @type {string}
   * @memberof BankAccount
   */
  account_number?: string;
  /**
   * The type of entity that holds the account.
   * @type {string}
   * @memberof BankAccount
   */
  account_type?: BankAccountAccountTypeEnum;
  /**
   * The signatory associated with your account. This name will be printed on checks created with this bank account. If you prefer to use a custom signature image on your checks instead, please create your bank account from the [Dashboard](https://dashboard.lob.com/#/login).
   * @type {string}
   * @memberof BankAccount
   */
  signatory?: string;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof BankAccount
   */
  metadata?: { [key: string]: string };
  /**
   * Unique identifier prefixed with `bank_`.
   * @type {string}
   * @memberof BankAccount
   */
  id: string;
  /**
   * A signed link to the signature image. will be generated.
   * @type {string}
   * @memberof BankAccount
   */
  signature_url?: string | null;
  /**
   * The name of the bank based on the provided routing number, e.g. `JPMORGAN CHASE BANK`.
   * @type {string}
   * @memberof BankAccount
   */
  bank_name?: string;
  /**
   * A bank account must be verified before a check can be created.
   * @type {boolean}
   * @memberof BankAccount
   */
  verified?: boolean;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof BankAccount
   */
  date_created?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was last modified.
   * @type {string}
   * @memberof BankAccount
   */
  date_modified?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof BankAccount
   */
  deleted?: boolean;
  /**
   *
   * @type {string}
   * @memberof BankAccount
   */
  object?: BankAccountObjectEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum BankAccountAccountTypeEnum {
  Company = "company",
  Individual = "individual",
}
/**
 * @export
 * @enum {string}
 */
export enum BankAccountObjectEnum {
  BankAccount = "bank_account",
}

/**
 * Lob uses RESTful HTTP response codes to indicate success or failure of an API request. In general, 2xx indicates success, 4xx indicate an input error, and 5xx indicates an error on Lob\'s end.
 * @export
 * @interface BankAccountDeletion
 */
export interface BankAccountDeletion {
  /**
   * Unique identifier prefixed with `bank_`.
   * @type {string}
   * @memberof BankAccountDeletion
   */
  id?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof BankAccountDeletion
   */
  deleted?: boolean;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof BankAccountDeletion
   */
  object?: BankAccountDeletionObjectEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum BankAccountDeletionObjectEnum {
  BankAccountDeleted = "bank_account_deleted",
}

/**
 *
 * @export
 * @interface BankAccountList
 */
export interface BankAccountList {
  /**
   * list of addresses
   * @type {Array<BankAccount>}
   * @memberof BankAccountList
   */
  data?: Array<BankAccount>;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof BankAccountList
   */
  object?: string;
  /**
   * Url of next page of items in list.
   * @type {string}
   * @memberof BankAccountList
   */
  next_url?: string | null;
  /**
   * Url of previous page of items in list.
   * @type {string}
   * @memberof BankAccountList
   */
  previous_url?: string | null;
  /**
   * number of resources in a set
   * @type {number}
   * @memberof BankAccountList
   */
  count?: number;
}
/**
 *
 * @export
 * @interface BankAccountVerify
 */
export interface BankAccountVerify {
  /**
   * In live mode, an array containing the two micro deposits (in cents) placed in the bank account. In test mode, no micro deposits will be placed, so any two integers between `1` and `100` will work.
   * @type {Array<number>}
   * @memberof BankAccountVerify
   */
  amounts: Array<number>;
}
/**
 *
 * @export
 * @interface BankAccountWritable
 */
export interface BankAccountWritable {
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof BankAccountWritable
   */
  description?: string | null;
  /**
   * Must be a [valid US routing number](https://www.frbservices.org/index.html).
   * @type {string}
   * @memberof BankAccountWritable
   */
  routing_number: string;
  /**
   *
   * @type {string}
   * @memberof BankAccountWritable
   */
  account_number: string;
  /**
   * The type of entity that holds the account.
   * @type {string}
   * @memberof BankAccountWritable
   */
  account_type: BankAccountWritableAccountTypeEnum;
  /**
   * The signatory associated with your account. This name will be printed on checks created with this bank account. If you prefer to use a custom signature image on your checks instead, please create your bank account from the [Dashboard](https://dashboard.lob.com/#/login).
   * @type {string}
   * @memberof BankAccountWritable
   */
  signatory: string;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof BankAccountWritable
   */
  metadata?: { [key: string]: string };
}

/**
 * @export
 * @enum {string}
 */
export enum BankAccountWritableAccountTypeEnum {
  Company = "company",
  Individual = "individual",
}

/**
 *
 * @export
 * @interface Card
 */
export interface Card {
  /**
   * Unique identifier prefixed with `card_`.
   * @type {string}
   * @memberof Card
   */
  id?: string;
  /**
   * The signed link for the card.
   * @type {string}
   * @memberof Card
   */
  url?: string;
  /**
   * True if the cards should be auto-reordered.
   * @type {boolean}
   * @memberof Card
   */
  auto_reorder?: boolean;
  /**
   * The number of cards to be reordered.
   * @type {number}
   * @memberof Card
   */
  reorder_quantity?: number | null;
  /**
   * The raw URL of the card.
   * @type {string}
   * @memberof Card
   */
  raw_url?: string;
  /**
   * The original URL of the front template.
   * @type {string}
   * @memberof Card
   */
  front_original_url?: string;
  /**
   * The original URL of the back template.
   * @type {string}
   * @memberof Card
   */
  back_original_url?: string;
  /**
   *
   * @type {Array<Thumbnail>}
   * @memberof Card
   */
  thumbnails?: Array<Thumbnail>;
  /**
   * The available quantity of cards.
   * @type {number}
   * @memberof Card
   */
  available_quantity?: number;
  /**
   * The pending quantity of cards.
   * @type {number}
   * @memberof Card
   */
  pending_quantity?: number;
  /**
   *
   * @type {string}
   * @memberof Card
   */
  status?: CardStatusEnum;
  /**
   * The orientation of the card.
   * @type {string}
   * @memberof Card
   */
  orientation?: CardOrientationEnum;
  /**
   * The threshold amount of the card
   * @type {number}
   * @memberof Card
   */
  threshold_amount?: number;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof Card
   */
  date_created?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was last modified.
   * @type {string}
   * @memberof Card
   */
  date_modified?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof Card
   */
  deleted?: boolean;
  /**
   * object
   * @type {string}
   * @memberof Card
   */
  object?: CardObjectEnum;
  /**
   * Description of the card.
   * @type {string}
   * @memberof Card
   */
  description?: string | null;
  /**
   * The size of the card
   * @type {string}
   * @memberof Card
   */
  size?: CardSizeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum CardStatusEnum {
  Processed = "processed",
  Rendered = "rendered",
}
/**
 * @export
 * @enum {string}
 */
export enum CardOrientationEnum {
  Horizontal = "horizontal",
  Vertical = "vertical",
}
/**
 * @export
 * @enum {string}
 */
export enum CardObjectEnum {
  Card = "card",
}
/**
 * @export
 * @enum {string}
 */
export enum CardSizeEnum {
  _3375x2125 = "3.375x2.125",
  _2125x3375 = "2.125x3.375",
}

/**
 * Lob uses RESTful HTTP response codes to indicate success or failure of an API request. In general, 2xx indicates success, 4xx indicate an input error, and 5xx indicates an error on Lob\'s end.
 * @export
 * @interface CardDeletion
 */
export interface CardDeletion {
  /**
   * Unique identifier prefixed with `card_`.
   * @type {string}
   * @memberof CardDeletion
   */
  id?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof CardDeletion
   */
  deleted?: boolean;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof CardDeletion
   */
  object?: CardDeletionObjectEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum CardDeletionObjectEnum {
  CardDeleted = "card_deleted",
}

/**
 *
 * @export
 * @interface CardEditable
 */
export interface CardEditable {
  /**
   * A PDF template for the front of the card
   * @type {string}
   * @memberof CardEditable
   */
  front?: string;
  /**
   * A PDF template for the back of the card
   * @type {string}
   * @memberof CardEditable
   */
  back?: string;
  /**
   * The size of the card
   * @type {string}
   * @memberof CardEditable
   */
  size?: CardEditableSizeEnum;
  /**
   * Description of the card.
   * @type {string}
   * @memberof CardEditable
   */
  description?: string | null;
}

/**
 * @export
 * @enum {string}
 */
export enum CardEditableSizeEnum {
  _3375x2125 = "3.375x2.125",
  _2125x3375 = "2.125x3.375",
}

/**
 *
 * @export
 * @interface CardList
 */
export interface CardList {
  /**
   * list of cards
   * @type {Array<Card>}
   * @memberof CardList
   */
  data?: Array<Card>;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof CardList
   */
  object?: string;
  /**
   * Url of next page of items in list.
   * @type {string}
   * @memberof CardList
   */
  next_url?: string | null;
  /**
   * Url of previous page of items in list.
   * @type {string}
   * @memberof CardList
   */
  previous_url?: string | null;
  /**
   * number of resources in a set
   * @type {number}
   * @memberof CardList
   */
  count?: number;
}
/**
 *
 * @export
 * @interface CardOrder
 */
export interface CardOrder {
  /**
   * Unique identifier prefixed with `co_`.
   * @type {string}
   * @memberof CardOrder
   */
  id?: string;
  /**
   * Unique identifier prefixed with `card_`.
   * @type {string}
   * @memberof CardOrder
   */
  card_id?: string;
  /**
   * The status of the card order.
   * @type {string}
   * @memberof CardOrder
   */
  status?: CardOrderStatusEnum;
  /**
   * The inventory of the card order.
   * @type {number}
   * @memberof CardOrder
   */
  inventory?: number;
  /**
   * The quantity of cards ordered
   * @type {number}
   * @memberof CardOrder
   */
  quantity_ordered?: number;
  /**
   * The unit price for the card order.
   * @type {number}
   * @memberof CardOrder
   */
  unit_price?: number;
  /**
   * The reason for cancellation.
   * @type {string}
   * @memberof CardOrder
   */
  cancelled_reason?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof CardOrder
   */
  availability_date?: string;
  /**
   * The fixed deadline for the cards to be printed.
   * @type {string}
   * @memberof CardOrder
   */
  expected_availability_date?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof CardOrder
   */
  date_created?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was last modified.
   * @type {string}
   * @memberof CardOrder
   */
  date_modified?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof CardOrder
   */
  deleted?: boolean;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof CardOrder
   */
  object?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum CardOrderStatusEnum {
  Pending = "pending",
  Printing = "printing",
  Available = "available",
  Cancelled = "cancelled",
  Depleted = "depleted",
}

/**
 *
 * @export
 * @interface CardOrderEditable
 */
export interface CardOrderEditable {
  /**
   *
   * @type {number}
   * @memberof CardOrderEditable
   */
  quantity?: number;
}
/**
 *
 * @export
 * @interface CardUpdatable
 */
export interface CardUpdatable {
  /**
   * Description of the card.
   * @type {string}
   * @memberof CardUpdatable
   */
  description?: string | null;
  /**
   * Allows for auto reordering
   * @type {boolean}
   * @memberof CardUpdatable
   */
  auto_reorder?: boolean;
  /**
   * The quantity of items to be reordered (only required when auto_reorder is true).
   * @type {number}
   * @memberof CardUpdatable
   */
  reorder_quantity?: number;
}
/**
 * Must be a 2 letter country short-name code (ISO 3166). Does not accept `US`, `AS`, `PR`, `FM`, `GU`, `MH`, `MP`, `PW`, or `VI`. For these addresses, please use the US verification API. Also does not accept `PS`, which is not currently supported.
 * @export
 * @enum {string}
 */

export enum CountryExtended {
  Ad = "AD",
  Ae = "AE",
  Af = "AF",
  Ag = "AG",
  Ai = "AI",
  Al = "AL",
  An = "AN",
  Ao = "AO",
  Aq = "AQ",
  Ar = "AR",
  At = "AT",
  Au = "AU",
  Aw = "AW",
  Az = "AZ",
  Ba = "BA",
  Bb = "BB",
  Bd = "BD",
  Be = "BE",
  Bf = "BF",
  Bg = "BG",
  Bh = "BH",
  Bi = "BI",
  Bj = "BJ",
  Bm = "BM",
  Bn = "BN",
  Bo = "BO",
  Bq = "BQ",
  Br = "BR",
  Bs = "BS",
  Bt = "BT",
  Bw = "BW",
  By = "BY",
  Bz = "BZ",
  Ca = "CA",
  Cd = "CD",
  Cg = "CG",
  Ch = "CH",
  Ci = "CI",
  Ck = "CK",
  Cl = "CL",
  Cm = "CM",
  Cn = "CN",
  Co = "CO",
  Cr = "CR",
  Cs = "CS",
  Cu = "CU",
  Cv = "CV",
  Cw = "CW",
  Cy = "CY",
  Cz = "CZ",
  De = "DE",
  Dj = "DJ",
  Dk = "DK",
  Dm = "DM",
  Do = "DO",
  Dz = "DZ",
  Ec = "EC",
  Ee = "EE",
  Eg = "EG",
  Eh = "EH",
  Er = "ER",
  Es = "ES",
  Et = "ET",
  Fi = "FI",
  Fj = "FJ",
  Fk = "FK",
  Fo = "FO",
  Fr = "FR",
  Ga = "GA",
  Gb = "GB",
  Gd = "GD",
  Ge = "GE",
  Gh = "GH",
  Gi = "GI",
  Gl = "GL",
  Gm = "GM",
  Gn = "GN",
  Gq = "GQ",
  Gr = "GR",
  Gs = "GS",
  Gt = "GT",
  Gw = "GW",
  Gy = "GY",
  Hk = "HK",
  Hn = "HN",
  Hr = "HR",
  Ht = "HT",
  Hu = "HU",
  Id = "ID",
  Ie = "IE",
  Il = "IL",
  In = "IN",
  Io = "IO",
  Iq = "IQ",
  Ir = "IR",
  Is = "IS",
  It = "IT",
  Jm = "JM",
  Jo = "JO",
  Jp = "JP",
  Ke = "KE",
  Kg = "KG",
  Kh = "KH",
  Ki = "KI",
  Km = "KM",
  Kn = "KN",
  Kp = "KP",
  Kr = "KR",
  Kw = "KW",
  Ky = "KY",
  Kz = "KZ",
  La = "LA",
  Lb = "LB",
  Lc = "LC",
  Li = "LI",
  Lk = "LK",
  Lr = "LR",
  Ls = "LS",
  Lt = "LT",
  Lu = "LU",
  Lv = "LV",
  Ly = "LY",
  Ma = "MA",
  Mc = "MC",
  Md = "MD",
  Me = "ME",
  Mg = "MG",
  Mk = "MK",
  Ml = "ML",
  Mm = "MM",
  Mn = "MN",
  Mo = "MO",
  Mr = "MR",
  Ms = "MS",
  Mt = "MT",
  Mu = "MU",
  Mv = "MV",
  Mw = "MW",
  Mx = "MX",
  My = "MY",
  Mz = "MZ",
  Na = "NA",
  Ne = "NE",
  Nf = "NF",
  Ng = "NG",
  Ni = "NI",
  Nl = "NL",
  No = "NO",
  Np = "NP",
  Nr = "NR",
  Nu = "NU",
  Nz = "NZ",
  Om = "OM",
  Pa = "PA",
  Pe = "PE",
  Pg = "PG",
  Ph = "PH",
  Pk = "PK",
  Pl = "PL",
  Pn = "PN",
  Pt = "PT",
  Py = "PY",
  Qa = "QA",
  Ro = "RO",
  Rs = "RS",
  Ru = "RU",
  Rw = "RW",
  Sa = "SA",
  Sb = "SB",
  Sc = "SC",
  Sd = "SD",
  Se = "SE",
  Sg = "SG",
  Sh = "SH",
  Si = "SI",
  Sk = "SK",
  Sl = "SL",
  Sm = "SM",
  Sn = "SN",
  So = "SO",
  Sr = "SR",
  Ss = "SS",
  St = "ST",
  Sv = "SV",
  Sx = "SX",
  Sy = "SY",
  Sz = "SZ",
  Tc = "TC",
  Td = "TD",
  Tg = "TG",
  Th = "TH",
  Tj = "TJ",
  Tk = "TK",
  Tl = "TL",
  Tm = "TM",
  Tn = "TN",
  To = "TO",
  Tr = "TR",
  Tt = "TT",
  Tv = "TV",
  Tw = "TW",
  Tz = "TZ",
  Ua = "UA",
  Ug = "UG",
  Us = "US",
  Uy = "UY",
  Uz = "UZ",
  Va = "VA",
  Vc = "VC",
  Ve = "VE",
  Vg = "VG",
  Vn = "VN",
  Vu = "VU",
  Ws = "WS",
  Ye = "YE",
  Za = "ZA",
  Zm = "ZM",
  Zw = "ZW",
}

/**
 * Full name of country
 * @export
 * @enum {string}
 */

export enum CountryExtendedExpanded {
  Afghanistan = "AFGHANISTAN",
  Albania = "ALBANIA",
  Algeria = "ALGERIA",
  AmericanSamoa = "AMERICAN SAMOA",
  Andorra = "ANDORRA",
  Angola = "ANGOLA",
  Anguilla = "ANGUILLA",
  Antarctica = "ANTARCTICA",
  AntiguaAndBarbuda = "ANTIGUA AND BARBUDA",
  Argentina = "ARGENTINA",
  Aruba = "ARUBA",
  Australia = "AUSTRALIA",
  Austria = "AUSTRIA",
  Azerbaijan = "AZERBAIJAN",
  Bahrain = "BAHRAIN",
  Bangladesh = "BANGLADESH",
  Barbados = "BARBADOS",
  Belarus = "BELARUS",
  Belgium = "BELGIUM",
  Belize = "BELIZE",
  Benin = "BENIN",
  Bermuda = "BERMUDA",
  Bhutan = "BHUTAN",
  BoliviaPlurinationalStateOf = "BOLIVIA (PLURINATIONAL STATE OF)",
  BonaireSaintEustatiusAndSaba = "BONAIRE, SAINT EUSTATIUS AND SABA",
  BosniaAndHerzegovina = "BOSNIA AND HERZEGOVINA",
  Botswana = "BOTSWANA",
  Brazil = "BRAZIL",
  BritishIndianOceanTerritory = "BRITISH INDIAN OCEAN TERRITORY",
  BritishVirginIslands = "BRITISH VIRGIN ISLANDS",
  BruneiDarussalam = "BRUNEI DARUSSALAM",
  Bulgaria = "BULGARIA",
  BurkinaFaso = "BURKINA FASO",
  Burundi = "BURUNDI",
  CaboVerde = "CABO VERDE",
  Cambodia = "CAMBODIA",
  Cameroon = "CAMEROON",
  Canada = "CANADA",
  CaymanIslands = "CAYMAN ISLANDS",
  CentralAfricanRepublic = "CENTRAL AFRICAN REPUBLIC",
  Chad = "CHAD",
  Chile = "CHILE",
  China = "CHINA",
  Colombia = "COLOMBIA",
  Comoros = "COMOROS",
  Congo = "CONGO",
  CongoDemocraticRepublicOfThe = "CONGO, DEMOCRATIC REPUBLIC OF THE",
  CookIslands = "COOK ISLANDS",
  CostaRica = "COSTA RICA",
  CteDivoire = "CÔTE D'IVOIRE",
  Croatia = "CROATIA",
  Cuba = "CUBA",
  Curaao = "CURAÇAO",
  Cyprus = "CYPRUS",
  CzechRepublic = "CZECH REPUBLIC",
  Denmark = "DENMARK",
  Djibouti = "DJIBOUTI",
  Dominica = "DOMINICA",
  DominicanRepublic = "DOMINICAN REPUBLIC",
  Ecuador = "ECUADOR",
  Egypt = "EGYPT",
  ElSalvador = "EL SALVADOR",
  EquatorialGuinea = "EQUATORIAL GUINEA",
  Eritrea = "ERITREA",
  Estonia = "ESTONIA",
  Eswatini = "ESWATINI",
  Ethiopia = "ETHIOPIA",
  FalklandIslandsMalvinas = "FALKLAND ISLANDS (MALVINAS)",
  FaroeIslands = "FAROE ISLANDS",
  Fiji = "FIJI",
  Finland = "FINLAND",
  France = "FRANCE",
  Gabon = "GABON",
  Gambia = "GAMBIA",
  Georgia = "GEORGIA",
  Germany = "GERMANY",
  Ghana = "GHANA",
  Gibraltar = "GIBRALTAR",
  Greece = "GREECE",
  Greenland = "GREENLAND",
  Grenada = "GRENADA",
  Guatemala = "GUATEMALA",
  Guinea = "GUINEA",
  GuineaBissau = "GUINEA-BISSAU",
  Guyana = "GUYANA",
  Haiti = "HAITI",
  HolySee = "HOLY SEE",
  Honduras = "HONDURAS",
  HongKong = "HONG KONG",
  Hungary = "HUNGARY",
  Iceland = "ICELAND",
  India = "INDIA",
  Indonesia = "INDONESIA",
  IranIslamicRepublicOf = "IRAN (ISLAMIC REPUBLIC OF)",
  Iraq = "IRAQ",
  Ireland = "IRELAND",
  Israel = "ISRAEL",
  Italy = "ITALY",
  Jamaica = "JAMAICA",
  Japan = "JAPAN",
  Jordan = "JORDAN",
  Kazakhstan = "KAZAKHSTAN",
  Kenya = "KENYA",
  Kiribati = "KIRIBATI",
  KoreaDemocraticPeoplesRepublicOf = "KOREA (DEMOCRATIC PEOPLE’S REPUBLIC OF)",
  KoreaRepublicOf = "KOREA, REPUBLIC OF",
  Kuwait = "KUWAIT",
  Kyrgyzstan = "KYRGYZSTAN",
  LaoPeoplesDemocraticRepublic = "LAO PEOPLE’S DEMOCRATIC REPUBLIC",
  Latvia = "LATVIA",
  Lebanon = "LEBANON",
  Lesotho = "LESOTHO",
  Liberia = "LIBERIA",
  Libya = "LIBYA",
  Liechtenstein = "LIECHTENSTEIN",
  Lithuania = "LITHUANIA",
  Luxembourg = "LUXEMBOURG",
  Macao = "MACAO",
  Macedonia = "MACEDONIA",
  Madagascar = "MADAGASCAR",
  Malawi = "MALAWI",
  Malaysia = "MALAYSIA",
  Maldives = "MALDIVES",
  Mali = "MALI",
  Malta = "MALTA",
  Mauritania = "MAURITANIA",
  Mauritius = "MAURITIUS",
  Mexico = "MEXICO",
  MoldovaRepublicOf = "MOLDOVA, REPUBLIC OF",
  Monaco = "MONACO",
  Mongolia = "MONGOLIA",
  Montenegro = "MONTENEGRO",
  Montserrat = "MONTSERRAT",
  Morocco = "MOROCCO",
  Mozambique = "MOZAMBIQUE",
  Myanmar = "MYANMAR",
  Namibia = "NAMIBIA",
  Nauru = "NAURU",
  Nepal = "NEPAL",
  NetherlandAntilles = "NETHERLAND ANTILLES",
  Netherlands = "NETHERLANDS",
  NewZealand = "NEW ZEALAND",
  Nicaragua = "NICARAGUA",
  Niger = "NIGER",
  Nigeria = "NIGERIA",
  Niue = "NIUE",
  NorfolkIsland = "NORFOLK ISLAND",
  Norway = "NORWAY",
  Oman = "OMAN",
  Pakistan = "PAKISTAN",
  Panama = "PANAMA",
  PapuaNewGuinea = "PAPUA NEW GUINEA",
  Paraguay = "PARAGUAY",
  Peru = "PERU",
  Philippines = "PHILIPPINES",
  Pitcairn = "PITCAIRN",
  Poland = "POLAND",
  Portugal = "PORTUGAL",
  Qatar = "QATAR",
  Romania = "ROMANIA",
  RussianFederation = "RUSSIAN FEDERATION",
  Rwanda = "RWANDA",
  SaintHelena = "SAINT HELENA",
  SaintKittsAndNevis = "SAINT KITTS AND NEVIS",
  SaintLucia = "SAINT LUCIA",
  SaintVincentAndTheGrenadines = "SAINT VINCENT AND THE GRENADINES",
  Samoa = "SAMOA",
  SanMarino = "SAN MARINO",
  SaoTomeAndPrincipe = "SAO TOME AND PRINCIPE",
  SaudiArabia = "SAUDI ARABIA",
  Senegal = "SENEGAL",
  Serbia = "SERBIA",
  Seychelles = "SEYCHELLES",
  SierraLeone = "SIERRA LEONE",
  Singapore = "SINGAPORE",
  SintMaarten = "SINT MAARTEN",
  Slovakia = "SLOVAKIA",
  Slovenia = "SLOVENIA",
  SolomonIslands = "SOLOMON ISLANDS",
  Somalia = "SOMALIA",
  SouthAfrica = "SOUTH AFRICA",
  SouthGeorgiaAndTheSouthSandwichIslands = "SOUTH GEORGIA AND THE SOUTH SANDWICH ISLANDS",
  SouthSudan = "SOUTH SUDAN",
  Spain = "SPAIN",
  SriLanka = "SRI LANKA",
  Sudan = "SUDAN",
  Suriname = "SURINAME",
  Sweden = "SWEDEN",
  Switzerland = "SWITZERLAND",
  SyrianArabRepublic = "SYRIAN ARAB REPUBLIC",
  Taiwan = "TAIWAN",
  Tajikistan = "TAJIKISTAN",
  Tanzania = "TANZANIA",
  Thailand = "THAILAND",
  TheBahamas = "THE BAHAMAS",
  TimorLeste = "TIMOR-LESTE",
  Togo = "TOGO",
  Tokelau = "TOKELAU",
  Tonga = "TONGA",
  TrinidadAndTobago = "TRINIDAD AND TOBAGO",
  Tunisia = "TUNISIA",
  Turkey = "TURKEY",
  Turkmenistan = "TURKMENISTAN",
  TurksAndCaicosIslands = "TURKS AND CAICOS ISLANDS",
  Tuvalu = "TUVALU",
  Uganda = "UGANDA",
  Ukraine = "UKRAINE",
  UnitedArabEmirates = "UNITED ARAB EMIRATES",
  UnitedKingdom = "UNITED KINGDOM",
  UnitedStates = "UNITED STATES",
  Uruguay = "URUGUAY",
  Uzbekistan = "UZBEKISTAN",
  Vanuatu = "VANUATU",
  Venezuela = "VENEZUELA",
  VietNam = "VIET NAM",
  WesternSahara = "WESTERN SAHARA",
  Yemen = "YEMEN",
  Zambia = "ZAMBIA",
  Zimbabwe = "ZIMBABWE",
}

/**
 * A nested object containing a breakdown of the deliverability of an address.
 * @export
 * @interface DeliverabilityAnalysis
 */
export interface DeliverabilityAnalysis {
  /**
   * Result of Delivery Point Validation (DPV), which determines whether or not the address is deliverable by the USPS. Possible values are: * `Y` –– The address is deliverable by the USPS. * `S` –– The address is deliverable by removing the provided secondary unit designator. This information may be incorrect or unnecessary. * `D` –– The address is deliverable to the building\'s default address but is missing a secondary unit designator and/or number.   There is a chance the mail will not reach the intended recipient. * `N` –– The address is not deliverable according to the USPS, but parts of the address are valid (such as the street and ZIP code). * `\'\'` –– This address is not deliverable. No matching street could be found within the city or ZIP code.
   * @type {string}
   * @memberof DeliverabilityAnalysis
   */
  dpv_confirmation?: DeliverabilityAnalysisDpvConfirmationEnum;
  /**
   * Indicates whether or not the address is [CMRA-authorized](https://en.wikipedia.org/wiki/Commercial_mail_receiving_agency). Possible values are: * `Y` –– Address is CMRA-authorized. * `N` –– Address is not CMRA-authorized. * `\'\'` –– A DPV match is not made (`deliverability_analysis[dpv_confirmation]` is `N` or an empty string).
   * @type {string}
   * @memberof DeliverabilityAnalysis
   */
  dpv_cmra?: DeliverabilityAnalysisDpvCmraEnum;
  /**
   * Indicates that an address was once deliverable, but has become vacant and is no longer receiving deliveries. Possible values are: * `Y` –– Address is vacant. * `N` –– Address is not vacant. * `\'\'` –– A DPV match is not made (`deliverability_analysis[dpv_confirmation]` is `N` or an empty string).
   * @type {string}
   * @memberof DeliverabilityAnalysis
   */
  dpv_vacant?: DeliverabilityAnalysisDpvVacantEnum;
  /**
   * Corresponds to the USPS field `dpv_no_stat`. Indicates that an address has been vacated in the recent past, and is no longer receiving deliveries. If it\'s been unoccupied for 90+ days, or temporarily vacant, this will be flagged. Possible values are: * `Y` –– Address is active. * `N` –– Address is not active. * `\'\'` –– A DPV match is not made (`deliverability_analysis[dpv_confirmation]` is `N` or an empty string).
   * @type {string}
   * @memberof DeliverabilityAnalysis
   */
  dpv_active?: DeliverabilityAnalysisDpvActiveEnum;
  /**
   * An array of 2-character strings that gives more insight into how `deliverability_analysis[dpv_confirmation]` was determined. Will always include at least 1 string, and can include up to 3. For details, see [US Verification Details](#tag/US-Verification-Types).
   * @type {Array<DpvFootnote>}
   * @memberof DeliverabilityAnalysis
   */
  dpv_footnotes?: Array<DpvFootnote>;
  /**
   * Indicates whether or not an address has been flagged in the [Early Warning System](https://docs.informatica.com/data-engineering/data-engineering-quality/10-4-0/address-validator-port-reference/postal-carrier-certification-data-ports/early-warning-system-return-code.html), meaning the address is under development and not yet ready to receive mail. However, it should become available in a few months.
   * @type {boolean}
   * @memberof DeliverabilityAnalysis
   */
  ews_match?: boolean;
  /**
   * Indicates whether this address has been converted by [LACS<sup>Link</sup>](https://postalpro.usps.com/address-quality/lacslink). LACS<sup>Link</sup> corrects outdated addresses into their modern counterparts. Possible values are: * `Y` –– New address produced with a matching record in LACS<sup>Link</sup>. * `N` –– New address could not be produced with a matching record in LACS<sup>Link</sup>. * `\'\'` –– A DPV match is not made (`deliverability_analysis[dpv_confirmation]` is `N` or an empty string).
   * @type {string}
   * @memberof DeliverabilityAnalysis
   */
  lacs_indicator?: DeliverabilityAnalysisLacsIndicatorEnum;
  /**
   * A code indicating how `deliverability_analysis[lacs_indicator]` was determined. Possible values are: * `A` — A new address was produced because a match was found in LACS<sup>Link</sup>. * `92` — A LACS<sup>Link</sup> record was matched after dropping secondary information. * `14` — A match was found in LACS<sup>Link</sup>, but could not be converted to a deliverable address. * `00` — A match was not found in LACS<sup>Link</sup>, and no new address was produced. * `\'\'` — LACS<sup>Link</sup> was not attempted.
   * @type {string}
   * @memberof DeliverabilityAnalysis
   */
  lacs_return_code?: string;
  /**
   * A return code that indicates whether the address was matched and corrected by [Suite<sup>Link</sup>](https://postalpro.usps.com/address-quality-solutions/suitelink). Suite<sup>Link</sup> attempts to provide secondary information to business addresses. Possible values are: * `A` –– A Suite<sup>Link</sup> match was found and secondary information was added. * `00` –– A Suite<sup>Link</sup> match could not be found and no secondary information was added. * `\'\'` –– Suite<sup>Link</sup> lookup was not attempted.
   * @type {string}
   * @memberof DeliverabilityAnalysis
   */
  suite_return_code?: DeliverabilityAnalysisSuiteReturnCodeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum DeliverabilityAnalysisDpvConfirmationEnum {
  Y = "Y",
  S = "S",
  D = "D",
  N = "N",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum DeliverabilityAnalysisDpvCmraEnum {
  Y = "Y",
  N = "N",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum DeliverabilityAnalysisDpvVacantEnum {
  Y = "Y",
  N = "N",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum DeliverabilityAnalysisDpvActiveEnum {
  Y = "Y",
  N = "N",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum DeliverabilityAnalysisLacsIndicatorEnum {
  Y = "Y",
  N = "N",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum DeliverabilityAnalysisSuiteReturnCodeEnum {
  A = "A",
  _00 = "00",
  Empty = "",
}

/**
 *
 * @export
 * @enum {string}
 */

export enum DpvFootnote {
  Aa = "AA",
  A1 = "A1",
  Bb = "BB",
  Cc = "CC",
  N1 = "N1",
  F1 = "F1",
  G1 = "G1",
  U1 = "U1",
  M1 = "M1",
  M3 = "M3",
  P1 = "P1",
  P3 = "P3",
  R1 = "R1",
  R7 = "R7",
  Rr = "RR",
}

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   * List of card orders
   * @type {Array<CardOrder>}
   * @memberof InlineResponse200
   */
  data?: Array<CardOrder>;
}
/**
 *
 * @export
 * @interface Letter
 */
export interface Letter {
  /**
   *
   * @type {Address}
   * @memberof Letter
   */
  to?: Address;
  /**
   *
   * @type {Address}
   * @memberof Letter
   */
  from?: Address;
  /**
   *
   * @type {string}
   * @memberof Letter
   */
  carrier?: LetterCarrierEnum;
  /**
   *
   * @type {Array<Thumbnail>}
   * @memberof Letter
   */
  thumbnails?: Array<Thumbnail>;
  /**
   * A date in YYYY-MM-DD format of the mailpiece\'s expected delivery date based on its `send_date`.
   * @type {string}
   * @memberof Letter
   */
  expected_delivery_date?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof Letter
   */
  date_created?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was last modified.
   * @type {string}
   * @memberof Letter
   */
  date_modified?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof Letter
   */
  deleted?: boolean;
  /**
   * Unique identifier prefixed with `ltr_`.
   * @type {string}
   * @memberof Letter
   */
  id?: string;
  /**
   * Unique identifier prefixed with `tmpl_`. ID of a saved [HTML template](#section/HTML-Templates).
   * @type {string}
   * @memberof Letter
   */
  template_id?: string;
  /**
   * Unique identifier prefixed with `vrsn_`.
   * @type {string}
   * @memberof Letter
   */
  template_version_id?: string;
  /**
   *
   * @type {string}
   * @memberof Letter
   */
  object?: LetterObjectEnum;
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof Letter
   */
  description?: string | null;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof Letter
   */
  metadata?: { [key: string]: string };
  /**
   * You can input a merge variable payload object to your template to render dynamic content. For example, if you have a template like: `{{variable_name}}`, pass in `{\"variable_name\": \"Harry\"}` to render `Harry`. `merge_variables` must be an object. Any type of value is accepted as long as the object is valid JSON; you can use `strings`, `numbers`, `booleans`, `arrays`, `objects`, or `null`. The max length of the object is 25,000 characters. If you call `JSON.stringify` on your object, it can be no longer than 25,000 characters. Your variable names cannot contain any whitespace or any of the following special characters: `!`, `\"`, `#`, `%`, `&`, `\'`, `(`, `)`, `*`, `+`, `,`, `/`, `;`, `<`, `=`, `>`, `@`, `[`, `\\`, `]`, `^`, `` ` ``, `{`, `|`, `}`, `~`. More instructions can be found in [our guide to using html and merge variables](https://lob.com/resources/guides/general/using-html-and-merge-variables). Depending on your [Merge Variable strictness](https://dashboard.lob.com/#/settings/account) setting, if you define variables in your HTML but do not pass them here, you will either receive an error or the variable will render as an empty string.
   * @type {object}
   * @memberof Letter
   */
  merge_variables?: object | null;
  /**
   *
   * @type {SendDate}
   * @memberof Letter
   */
  send_date?: SendDate;
  /**
   * Add an extra service to your letter. See [pricing](https://www.lob.com/pricing/print-mail#compare) for extra costs incurred.   * registered - provides tracking and confirmation for international addresses   * `certified` - track and confirm delivery for domestic destinations. An extra sheet (1 PDF page single-sided or 2 PDF pages double-sided) is added to the beginning of your letter for address and barcode information. See here for templates: [#10 envelope](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_certified_template.pdf) and [flat envelope](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_certified_flat_template.pdf) (used for letters over 6 pages single-sided or 12 pages double-sided). You will not be charged for this extra sheet.   * `certified_return_receipt` - request an electronic copy of the recipient\'s signature to prove delivery of your certified letter
   * @type {string}
   * @memberof Letter
   */
  extra_service?: string;
  /**
   * The tracking number, if applicable, will appear here when it becomes available. Dummy tracking numbers are not created in test mode.
   * @type {string}
   * @memberof Letter
   */
  tracking_number?: string | null;
  /**
   * Tracking events are not populated for registered or regular (no extra service) letters.
   * @type {Array<TrackingEventNormal>}
   * @memberof Letter
   */
  tracking_events?: Array<TrackingEventNormal>;
  /**
   *
   * @type {ReturnAddress}
   * @memberof Letter
   */
  return_address?: ReturnAddress;
  /**
   *
   * @type {MailType}
   * @memberof Letter
   */
  mail_type?: MailType;
  /**
   * Set this key to `true` if you would like to print in color. Set to `false` if you would like to print in black and white.
   * @type {boolean}
   * @memberof Letter
   */
  color?: boolean;
  /**
   * Set this attribute to `true` for double sided printing, or `false` for for single sided printing. Defaults to `true`.
   * @type {boolean}
   * @memberof Letter
   */
  double_sided?: boolean;
  /**
   * Specifies the location of the address information that will show through the double-window envelope. To see how this will impact your letter design, view our letter template.   * `top_first_page` - (default) print address information at the top of your provided first page   * `insert_blank_page` - insert a blank address page at the beginning of your file (you will be charged for the extra page)   * `bottom_first_page_center` - **(deprecation planned within a few months)** print address information at the bottom center of your provided first page   * `bottom_first_page` - print address information at the bottom of your provided first page
   * @type {string}
   * @memberof Letter
   */
  address_placement?: LetterAddressPlacementEnum;
  /**
   * Indicates if a return envelope is requested for the letter. The value corresponding to this field is by default a boolean. But if the account is signed up for custom return envelopes, the value is of type string and is `no_9_single_window` for a standard return envelope and a custom `return_envelope_id` for non-standard return envelopes.  To include a return envelope with your letter, set to `true` and specify the `perforated_page`. See [pricing](https://www.lob.com/pricing/print-mail#compare) for extra costs incurred.
   * @type {boolean | string}
   * @memberof Letter
   */
  return_envelope?: boolean | string;
  /**
   * Required if `return_envelope` is `true`. The number of the page that should be perforated for use with the return envelope. Must be greater than or equal to `1`. The blank page added by `address_placement=insert_blank_page` will be ignored when considering the perforated page number. To see how perforation will impact your letter design, view our [perforation guide](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_perf_template.pdf).
   * @type {number}
   * @memberof Letter
   */
  perforated_page?: number | null;
  /**
   *
   * @type {LetterCustomEnvelope}
   * @memberof Letter
   */
  custom_envelope?: LetterCustomEnvelope | null;
}

/**
 * @export
 * @enum {string}
 */
export enum LetterCarrierEnum {
  Usps = "USPS",
}
/**
 * @export
 * @enum {string}
 */
export enum LetterObjectEnum {
  Letter = "letter",
}
/**
 * @export
 * @enum {string}
 */
export enum LetterAddressPlacementEnum {
  TopFirstPage = "top_first_page",
  InsertBlankPage = "insert_blank_page",
  BottomFirstPageCenter = "bottom_first_page_center",
  BottomFirstPage = "bottom_first_page",
}

/**
 * A nested custom envelope object containing more information about the custom envelope used or `null` if a custom envelope was not used.  Accepts an envelope ID for any customized envelope with available inventory. If no inventory is available for the specified ID, the letter will not be sent, and an error will be returned. If the letter has more than 6 sheets, it will be sent in a blank flat envelope. Custom envelopes may be created and ordered from the dashboard. This feature is exclusive to certain customers. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
 * @export
 * @interface LetterCustomEnvelope
 */
export interface LetterCustomEnvelope {
  /**
   * The unique identifier of the custom envelope used.
   * @type {string}
   * @memberof LetterCustomEnvelope
   */
  id: string;
  /**
   * The url of the envelope asset used.
   * @type {string}
   * @memberof LetterCustomEnvelope
   */
  url: string;
  /**
   *
   * @type {string}
   * @memberof LetterCustomEnvelope
   */
  object: LetterCustomEnvelopeObjectEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum LetterCustomEnvelopeObjectEnum {
  Envelope = "envelope",
}

/**
 * Lob uses RESTful HTTP response codes to indicate success or failure of an API request. In general, 2xx indicates success, 4xx indicate an input error, and 5xx indicates an error on Lob\'s end.
 * @export
 * @interface LetterDeletion
 */
export interface LetterDeletion {
  /**
   * Unique identifier prefixed with `ltr_`.
   * @type {string}
   * @memberof LetterDeletion
   */
  id?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof LetterDeletion
   */
  deleted?: boolean;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof LetterDeletion
   */
  object?: LetterDeletionObjectEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum LetterDeletionObjectEnum {
  LetterDeleted = "letter_deleted",
}

/**
 *
 * @export
 * @interface LetterEditable
 */
export interface LetterEditable {
  /**
   *
   * @type {MailType}
   * @memberof LetterEditable
   */
  mail_type?: MailType;
  /**
   * Set this key to `true` if you would like to print in color. Set to `false` if you would like to print in black and white.
   * @type {boolean}
   * @memberof LetterEditable
   */
  color?: boolean;
  /**
   * Set this attribute to `true` for double sided printing, or `false` for for single sided printing. Defaults to `true`.
   * @type {boolean}
   * @memberof LetterEditable
   */
  double_sided?: boolean;
  /**
   * Specifies the location of the address information that will show through the double-window envelope. To see how this will impact your letter design, view our letter template.   * `top_first_page` - (default) print address information at the top of your provided first page   * `insert_blank_page` - insert a blank address page at the beginning of your file (you will be charged for the extra page)   * `bottom_first_page_center` - **(deprecation planned within a few months)** print address information at the bottom center of your provided first page   * `bottom_first_page` - print address information at the bottom of your provided first page
   * @type {string}
   * @memberof LetterEditable
   */
  address_placement?: LetterEditableAddressPlacementEnum;
  /**
   * Indicates if a return envelope is requested for the letter. The value corresponding to this field is by default a boolean. But if the account is signed up for custom return envelopes, the value is of type string and is `no_9_single_window` for a standard return envelope and a custom `return_envelope_id` for non-standard return envelopes.  To include a return envelope with your letter, set to `true` and specify the `perforated_page`. See [pricing](https://www.lob.com/pricing/print-mail#compare) for extra costs incurred.
   * @type {boolean | string}
   * @memberof LetterEditable
   */
  return_envelope?: boolean | string;
  /**
   * Required if `return_envelope` is `true`. The number of the page that should be perforated for use with the return envelope. Must be greater than or equal to `1`. The blank page added by `address_placement=insert_blank_page` will be ignored when considering the perforated page number. To see how perforation will impact your letter design, view our [perforation guide](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_perf_template.pdf).
   * @type {number}
   * @memberof LetterEditable
   */
  perforated_page?: number | null;
  /**
   *
   * @type {LetterCustomEnvelope}
   * @memberof LetterEditable
   */
  custom_envelope?: LetterCustomEnvelope | null;
  /**
   * Must either be an address ID or an inline object with correct address parameters. If an object is used, an address will be created, corrected, and standardized for free whenever possible using our US Address Verification engine (if it is a US address), and returned back with an ID. Depending on your [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions), US addresses may also be run through [National Change of Address (NCOA)](https://lob.com/docs#ncoa). Non-US addresses will be standardized into uppercase only. If a US address used does not meet your account’s [US Mail strictness setting](https://dashboard.lob.com/#/settings/account), the request will fail. [Lob Guide: Verification of Mailing Addresses](https://www.lob.com/guides#mailing_addresses)
   * @type {string | AddressEditable}
   * @memberof LetterEditable
   */
  to: string | AddressEditable;
  /**
   * Must either be an address ID or an inline object with correct address parameters. Must be a US address unless using a `custom_envelope`. All addresses will be standardized into uppercase without being modified by verification.
   * @type {string | AddressEditable}
   * @memberof LetterEditable
   */
  from: string | AddressEditable;
  /**
   * Notes: - HTML merge variables should not include delimiting whitespace. - All pages of a supplied PDF file must be sized at 8.5\"x11\", while supplied HTML will be rendered and trimmed to as many 8.5\"x11\" pages as necessary. - For design specifications, please see our [PDF](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_template.pdf) and [HTML](#section/HTML-Examples) templates. - If a `custom_envelope` is used, follow [this template](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_custom_envelope.pdf). - For domestic destinations, the file limit is 60 pages single-sided or 120 pages double-sided. For international destinations, the file limit is 6 pages single-sided or 12 pages double-sided. PDFs that surpass the file limit will error, while HTML that renders more pages than the file limit will be trimmed. - Any letters over 6 pages single-sided or 12 pages double-sided will be placed in a [flat envelope](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_flat_template.pdf) instead of the standard double window envelope.  See [pricing](https://lob.com/pricing/print-mail#compare) for extra costs incurred.
   * @type {string}
   * @memberof LetterEditable
   */
  file: string;
  /**
   * Add an extra service to your letter. See [pricing](https://www.lob.com/pricing/print-mail#compare) for extra costs incurred.   * `certified` - track and confirm delivery for domestic destinations. An extra sheet (1 PDF page single-sided or 2 PDF pages double-sided) is added to the beginning of your letter for address and barcode information. See here for templates: [#10 envelope](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_certified_template.pdf) and [flat envelope](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/letter_certified_flat_template.pdf) (used for letters over 6 pages single-sided or 12 pages double-sided). You will not be charged for this extra sheet.   * `certified_return_receipt` - request an electronic copy of the recipient\'s signature to prove delivery of your certified letter   * `registered` - provides tracking and confirmation for international addresses
   * @type {string}
   * @memberof LetterEditable
   */
  extra_service?: LetterEditableExtraServiceEnum;
  /**
   * A single-element array containing an existing card id in a string format. See [cards](#tag/Cards) for more information.
   * @type {Array<string>}
   * @memberof LetterEditable
   */
  cards?: Array<string> | null;
  /**
   * An optional string with the billing group ID to tag your usage with. Is used for billing purposes. Requires special activation to use. See [Billing Group API](https://lob.github.io/lob-openapi/#tag/Billing-Groups) for more information.
   * @type {string}
   * @memberof LetterEditable
   */
  billing_group_id?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum LetterEditableAddressPlacementEnum {
  TopFirstPage = "top_first_page",
  InsertBlankPage = "insert_blank_page",
  BottomFirstPageCenter = "bottom_first_page_center",
  BottomFirstPage = "bottom_first_page",
}
/**
 * @export
 * @enum {string}
 */
export enum LetterEditableExtraServiceEnum {
  Certified = "certified",
  CertifiedReturnReceipt = "certified_return_receipt",
  Registered = "registered",
  Null = "null",
}

/**
 *
 * @export
 * @interface LetterList
 */
export interface LetterList {
  /**
   * list of letters
   * @type {Array<Letter>}
   * @memberof LetterList
   */
  data?: Array<Letter>;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof LetterList
   */
  object?: string;
  /**
   * Url of next page of items in list.
   * @type {string}
   * @memberof LetterList
   */
  next_url?: string | null;
  /**
   * Url of previous page of items in list.
   * @type {string}
   * @memberof LetterList
   */
  previous_url?: string | null;
  /**
   * number of resources in a set
   * @type {number}
   * @memberof LetterList
   */
  count?: number;
}
/**
 * Lob Confidence Score is a nested object that provides a numerical value between 0-100 of the likelihood that an address is deliverable based on Lob’s mail delivery data to over half of US households.
 * @export
 * @interface LobConfidenceScore
 */
export interface LobConfidenceScore {
  /**
   * A numerical score between 0 and 100 that represents the percentage of mailpieces Lob has sent to this addresses that have been delivered successfully over the past 2 years. Will be `null` if no tracking data exists for this address.
   * @type {number}
   * @memberof LobConfidenceScore
   */
  score?: number | null;
  /**
   * Indicates the likelihood that the address is a valid, mail-receiving address. Possible values are:   - `high` — Over 70% of mailpieces Lob has sent to this address were delivered successfully and recent mailings were also successful.   - `medium` — Between 40% and 70% of mailpieces Lob has sent to this address were delivered successfully.   - `low` — Less than 40% of mailpieces Lob has sent to this address were delivered successfully and recent mailings weren\'t successful.   - `\"\"` — No tracking data exists for this address or lob deliverability was unable to find a corresponding level of mail success.
   * @type {string}
   * @memberof LobConfidenceScore
   */
  level?: LobConfidenceScoreLevelEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum LobConfidenceScoreLevelEnum {
  High = "high",
  Medium = "medium",
  Low = "low",
  Empty = "",
}

/**
 * Lob uses RESTful HTTP response codes to indicate success or failure of an API request. In general, 2xx indicates success, 4xx indicate an input error, and 5xx indicates an error on Lob\'s end.
 * @export
 * @interface LobError
 */
export interface LobError {
  /**
   * A human-readable message with more details about the error
   * @type {string}
   * @memberof LobError
   */
  message?: string;
  /**
   * A conventional HTTP status code:   * `401` - Authorization error with your API key or account   * `403` - Forbidden error with your API key or account   * `404` - The requested item does not exist   * `413` - Payload too large   * `422` - The query or body parameters did not pass validation   * `429` - Too many requests have been sent with an API key in a given amount of time   * `500` - An internal server error occurred, please contact support@lob.com
   * @type {number}
   * @memberof LobError
   */
  status_code?: LobErrorStatusCodeEnum;
  /**
   * A pre-defined string identifying an error.
   * @type {string}
   * @memberof LobError
   */
  code?: LobErrorCodeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum LobErrorStatusCodeEnum {
  NUMBER_401 = 401,
  NUMBER_403 = 403,
  NUMBER_404 = 404,
  NUMBER_413 = 413,
  NUMBER_422 = 422,
  NUMBER_429 = 429,
  NUMBER_500 = 500,
}
/**
 * @export
 * @enum {string}
 */
export enum LobErrorCodeEnum {
  BadRequest = "bad_request",
  Conflict = "conflict",
  FeatureLimitReached = "feature_limit_reached",
  InternalServerError = "internal_server_error",
  Invalid = "invalid",
  NotDeletable = "not_deletable",
  NotFound = "not_found",
  RequestTimeout = "request_timeout",
  ServiceUnavailable = "service_unavailable",
  UnrecognizedEndpoint = "unrecognized_endpoint",
  UnsupportedLobVersion = "unsupported_lob_version",
  AddressLengthExceedsLimit = "address_length_exceeds_limit",
  BankAccountAlreadyVerified = "bank_account_already_verified",
  BankError = "bank_error",
  CustomEnvelopeInventoryDepleted = "custom_envelope_inventory_depleted",
  DeletedBankAccount = "deleted_bank_account",
  FailedDeliverabilityStrictness = "failed_deliverability_strictness",
  FilePagesBelowMin = "file_pages_below_min",
  FilePagesExceedMax = "file_pages_exceed_max",
  FileSizeExceedsLimit = "file_size_exceeds_limit",
  ForeignReturnAddress = "foreign_return_address",
  InconsistentPageDimensions = "inconsistent_page_dimensions",
  InvalidBankAccount = "invalid_bank_account",
  InvalidBankAccountVerification = "invalid_bank_account_verification",
  InvalidCheckInternational = "invalid_check_international",
  InvalidCountryCovid = "invalid_country_covid",
  InvalidFile = "invalid_file",
  InvalidFileDimensions = "invalid_file_dimensions",
  InvalidFileDownloadTime = "invalid_file_download_time",
  InvalidFileUrl = "invalid_file_url",
  InvalidImageDpi = "invalid_image_dpi",
  InvalidInternationalFeature = "invalid_international_feature",
  InvalidPerforationReturnEnvelope = "invalid_perforation_return_envelope",
  InvalidTemplateHtml = "invalid_template_html",
  MergeVariableRequired = "merge_variable_required",
  MergeVariableWhitespace = "merge_variable_whitespace",
  PaymentMethodUnverified = "payment_method_unverified",
  PdfEncrypted = "pdf_encrypted",
  SpecialCharactersRestricted = "special_characters_restricted",
  UnembeddedFonts = "unembedded_fonts",
  EmailRequired = "email_required",
  InvalidApiKey = "invalid_api_key",
  PublishableKeyNotAllowed = "publishable_key_not_allowed",
  RateLimitExceeded = "rate_limit_exceeded",
  Unauthorized = "unauthorized",
  UnauthorizedToken = "unauthorized_token",
}

/**
 * A string designating the mail postage type: * `usps_first_class` - (default) * `usps_standard` - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. `usps_standard` cannot be used with `4x6` postcards or for any postcards sent outside of the United States.
 * @export
 * @enum {string}
 */

export enum MailType {
  FirstClass = "usps_first_class",
  Standard = "usps_standard",
}

/**
 *
 * @export
 * @interface MultipleComponents
 */
export interface MultipleComponents {
  /**
   * The intended recipient, typically a person\'s or firm\'s name.
   * @type {string}
   * @memberof MultipleComponents
   */
  recipient?: string | null;
  /**
   * The primary delivery line (usually the street address) of the address. Combination of the following applicable `components`: * `primary_number` * `street_predirection` * `street_name` * `street_suffix` * `street_postdirection` * `secondary_designator` * `secondary_number` * `pmb_designator` * `pmb_number`
   * @type {string}
   * @memberof MultipleComponents
   */
  primary_line: string;
  /**
   * The secondary delivery line of the address. This field is typically empty but may contain information if `primary_line` is too long.
   * @type {string}
   * @memberof MultipleComponents
   */
  secondary_line?: string;
  /**
   * Only present for addresses in Puerto Rico. An urbanization refers to an area, sector, or development within a city. See [USPS documentation](https://pe.usps.com/text/pub28/28api_008.htm#:~:text=I51.,-4%20Urbanizations&text=In%20Puerto%20Rico%2C%20identical%20street,placed%20before%20the%20urbanization%20name.) for clarification.
   * @type {string}
   * @memberof MultipleComponents
   */
  urbanization?: string;
  /**
   *
   * @type {string}
   * @memberof MultipleComponents
   */
  city?: string;
  /**
   * The [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2:US) two letter code or subdivision name for the state. `city` and `state` are required if no `zip_code` is passed.
   * @type {string}
   * @memberof MultipleComponents
   */
  state?: string;
  /**
   * Required if `city` and `state` are not passed in. If included, must be formatted as a US ZIP or ZIP+4 (e.g. `94107`, `941072282`, `94107-2282`).
   * @type {string}
   * @memberof MultipleComponents
   */
  zip_code?: string;
}
/**
 *
 * @export
 * @interface Postcard
 */
export interface Postcard {
  /**
   * Unique identifier prefixed with `psc_`.
   * @type {string}
   * @memberof Postcard
   */
  id: string;
  /**
   *
   * @type {Address}
   * @memberof Postcard
   */
  to?: Address;
  /**
   *
   * @type {AddressDomesticExpanded}
   * @memberof Postcard
   */
  from?: AddressDomesticExpanded;
  /**
   *
   * @type {string}
   * @memberof Postcard
   */
  carrier?: PostcardCarrierEnum;
  /**
   *
   * @type {Array<Thumbnail>}
   * @memberof Postcard
   */
  thumbnails?: Array<Thumbnail>;
  /**
   *
   * @type {PostcardSize}
   * @memberof Postcard
   */
  size?: PostcardSize;
  /**
   * A date in YYYY-MM-DD format of the mailpiece\'s expected delivery date based on its `send_date`.
   * @type {string}
   * @memberof Postcard
   */
  expected_delivery_date?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof Postcard
   */
  date_created?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was last modified.
   * @type {string}
   * @memberof Postcard
   */
  date_modified?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof Postcard
   */
  deleted?: boolean;
  /**
   * The unique ID of the HTML template used for the front of the postcard.
   * @type {string}
   * @memberof Postcard
   */
  front_template_id: string | null;
  /**
   * The unique ID of the HTML template used for the back of the postcard.
   * @type {string}
   * @memberof Postcard
   */
  back_template_id: string | null;
  /**
   * The unique ID of the specific version of the HTML template used for the front of the postcard.
   * @type {string}
   * @memberof Postcard
   */
  front_template_version_id: string | null;
  /**
   * The unique ID of the specific version of the HTML template used for the back of the postcard.
   * @type {string}
   * @memberof Postcard
   */
  back_template_version_id: string | null;
  /**
   * An array of tracking_event objects ordered by ascending `time`. Will not be populated for postcards created in test mode.
   * @type {Array<TrackingEventNormal>}
   * @memberof Postcard
   */
  tracking_events?: Array<TrackingEventNormal> | null;
  /**
   *
   * @type {string}
   * @memberof Postcard
   */
  object?: PostcardObjectEnum;
  /**
   * A [signed link](#section/Asset-URLs) served over HTTPS. The link returned will expire in 30 days to prevent mis-sharing. Each time a GET request is initiated, a new signed URL will be generated.
   * @type {string}
   * @memberof Postcard
   */
  url: string;
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof Postcard
   */
  description?: string | null;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof Postcard
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {MailType}
   * @memberof Postcard
   */
  mail_type?: MailType;
  /**
   * You can input a merge variable payload object to your template to render dynamic content. For example, if you have a template like: `{{variable_name}}`, pass in `{\"variable_name\": \"Harry\"}` to render `Harry`. `merge_variables` must be an object. Any type of value is accepted as long as the object is valid JSON; you can use `strings`, `numbers`, `booleans`, `arrays`, `objects`, or `null`. The max length of the object is 25,000 characters. If you call `JSON.stringify` on your object, it can be no longer than 25,000 characters. Your variable names cannot contain any whitespace or any of the following special characters: `!`, `\"`, `#`, `%`, `&`, `\'`, `(`, `)`, `*`, `+`, `,`, `/`, `;`, `<`, `=`, `>`, `@`, `[`, `\\`, `]`, `^`, `` ` ``, `{`, `|`, `}`, `~`. More instructions can be found in [our guide to using html and merge variables](https://lob.com/resources/guides/general/using-html-and-merge-variables). Depending on your [Merge Variable strictness](https://dashboard.lob.com/#/settings/account) setting, if you define variables in your HTML but do not pass them here, you will either receive an error or the variable will render as an empty string.
   * @type {object}
   * @memberof Postcard
   */
  merge_variables?: object | null;
  /**
   *
   * @type {SendDate}
   * @memberof Postcard
   */
  send_date?: SendDate;
}

/**
 * @export
 * @enum {string}
 */
export enum PostcardCarrierEnum {
  Usps = "USPS",
}
/**
 * @export
 * @enum {string}
 */
export enum PostcardObjectEnum {
  Postcard = "postcard",
}

/**
 * Lob uses RESTful HTTP response codes to indicate success or failure of an API request. In general, 2xx indicates success, 4xx indicate an input error, and 5xx indicates an error on Lob\'s end.
 * @export
 * @interface PostcardDeletion
 */
export interface PostcardDeletion {
  /**
   * Unique identifier prefixed with `psc_`.
   * @type {string}
   * @memberof PostcardDeletion
   */
  id?: string;
  /**
   * Only returned if the resource has been successfully deleted.
   * @type {boolean}
   * @memberof PostcardDeletion
   */
  deleted?: boolean;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof PostcardDeletion
   */
  object?: PostcardDeletionObjectEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum PostcardDeletionObjectEnum {
  PostcardDeleted = "postcard_deleted",
}

/**
 *
 * @export
 * @interface PostcardEditable
 */
export interface PostcardEditable {
  /**
   * Must either be an address ID or an inline object with correct address parameters. If an object is used, an address will be created, corrected, and standardized for free whenever possible using our US Address Verification engine (if it is a US address), and returned back with an ID. Depending on your [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions), US addresses may also be run through [National Change of Address (NCOA)](https://lob.com/docs#ncoa). Non-US addresses will be standardized into uppercase only. If a US address used does not meet your account’s [US Mail strictness setting](https://dashboard.lob.com/#/settings/account), the request will fail. [Lob Guide: Verification of Mailing Addresses](https://www.lob.com/guides#mailing_addresses)
   * @type {string | AddressEditable}
   * @memberof PostcardEditable
   */
  to: string | AddressEditable;
  /**
   * *Required* if `to` address is international. Must either be an address ID or an inline object with correct address parameters. Must either be an address ID or an inline object with correct address parameters. All addresses will be standardized into uppercase without being modified by verification.
   * @type {string | AddressDomestic}
   * @memberof PostcardEditable
   */
  from?: string | AddressDomestic;
  /**
   *
   * @type {PostcardSize}
   * @memberof PostcardEditable
   */
  size?: PostcardSize;
  /**
   * An internal description that identifies this resource. Must be no longer than 255 characters.
   * @type {string}
   * @memberof PostcardEditable
   */
  description?: string | null;
  /**
   * Use metadata to store custom information for tagging and labeling back to your internal systems. Must be an object with up to 20 key-value pairs. Keys must be at most 40 characters and values must be at most 500 characters. Neither can contain the characters `\"` and `\\`. i.e. \'{\"customer_id\" : \"NEWYORK2015\"}\' Nested objects are not supported.  See [Metadata](#section/Metadata) for more information.
   * @type {{ [key: string]: string; }}
   * @memberof PostcardEditable
   */
  metadata?: { [key: string]: string };
  /**
   *
   * @type {MailType}
   * @memberof PostcardEditable
   */
  mail_type?: MailType;
  /**
   * You can input a merge variable payload object to your template to render dynamic content. For example, if you have a template like: `{{variable_name}}`, pass in `{\"variable_name\": \"Harry\"}` to render `Harry`. `merge_variables` must be an object. Any type of value is accepted as long as the object is valid JSON; you can use `strings`, `numbers`, `booleans`, `arrays`, `objects`, or `null`. The max length of the object is 25,000 characters. If you call `JSON.stringify` on your object, it can be no longer than 25,000 characters. Your variable names cannot contain any whitespace or any of the following special characters: `!`, `\"`, `#`, `%`, `&`, `\'`, `(`, `)`, `*`, `+`, `,`, `/`, `;`, `<`, `=`, `>`, `@`, `[`, `\\`, `]`, `^`, `` ` ``, `{`, `|`, `}`, `~`. More instructions can be found in [our guide to using html and merge variables](https://lob.com/resources/guides/general/using-html-and-merge-variables). Depending on your [Merge Variable strictness](https://dashboard.lob.com/#/settings/account) setting, if you define variables in your HTML but do not pass them here, you will either receive an error or the variable will render as an empty string.
   * @type {object}
   * @memberof PostcardEditable
   */
  merge_variables?: object | null;
  /**
   *
   * @type {SendDate}
   * @memberof PostcardEditable
   */
  send_date?: SendDate;
  /**
   * The artwork to use as the front of your postcard.  Notes: - HTML merge variables should not include delimiting whitespace. - PDF, PNG, and JPGs must be sized at 4.25\"x6.25\", 6.25\"x9.25\", or 6.25\"x11.25\" at 300 DPI, while supplied HTML will be rendered to the specified `size`.  See [here](#section/HTML-Examples) for HTML examples.
   * @type {string}
   * @memberof PostcardEditable
   */
  front: string;
  /**
   * The artwork to use as the back of your postcard.  Notes: - HTML merge variables should not include delimiting whitespace. - PDF, PNG, and JPGs must be sized at 4.25\"x6.25\", 6.25\"x9.25\", or 6.25\"x11.25\" at 300 DPI, while supplied HTML will be rendered to the specified `size`. - Be sure to leave room for address and postage information by following the templates provided here:   - [4x6 template](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/postcards/4x6_postcard.pdf)   - [6x9 template](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/postcards/6x9_postcard.pdf)   - [6x11 template](https://s3-us-west-2.amazonaws.com/public.lob.com/assets/templates/postcards/6x11_postcard.pdf)   See [here](#section/HTML-Examples) for HTML examples.
   * @type {string}
   * @memberof PostcardEditable
   */
  back: string;
  /**
   * An optional string with the billing group ID to tag your usage with. Is used for billing purposes. Requires special activation to use. See [Billing Group API](https://lob.github.io/lob-openapi/#tag/Billing-Groups) for more information.
   * @type {string}
   * @memberof PostcardEditable
   */
  billing_group_id?: string;
}
/**
 *
 * @export
 * @interface PostcardList
 */
export interface PostcardList {
  /**
   * list of postcards
   * @type {Array<Postcard>}
   * @memberof PostcardList
   */
  data?: Array<Postcard>;
  /**
   * Value is type of resource.
   * @type {string}
   * @memberof PostcardList
   */
  object?: string;
  /**
   * Url of next page of items in list.
   * @type {string}
   * @memberof PostcardList
   */
  next_url?: string | null;
  /**
   * Url of previous page of items in list.
   * @type {string}
   * @memberof PostcardList
   */
  previous_url?: string | null;
  /**
   * number of resources in a set
   * @type {number}
   * @memberof PostcardList
   */
  count?: number;
}
/**
 * Specifies the size of the postcard. Only `4x6` postcards can be sent to international destinations.
 * @export
 * @enum {string}
 */

export enum PostcardSize {
  _4x6 = "4x6",
  _6x9 = "6x9",
  _6x11 = "6x11",
}

/**
 * @type ReturnAddress
 * Specifies the address the return envelope will be sent back to. This is an optional argument that is available if an account is signed up for the return envelope tracking beta, and has `return_envelope`, and `perforated_page` fields populated in the API request.
 * @export
 */
export type ReturnAddress = AddressEditable | string;

/**
 * A timestamp in ISO 8601 format which specifies a date after the current time and up to 180 days in the future to send the letter off for production. Setting a send date overrides the default [cancellation window](#section/Cancellation-Windows) applied to the mailpiece. Until the `send_date` has passed, the mailpiece can be canceled. If a date in the format `2017-11-01` is passed, it will evaluate to midnight UTC of that date (`2017-11-01T00:00:00.000Z`). If a datetime is passed, that exact time will be used. A `send_date` passed with no time zone will default to UTC, while a `send_date` passed with a time zone will be converted to UTC.
 * @export
 * @interface SendDate
 */
export interface SendDate {}
/**
 *
 * @export
 * @interface SingleLineAddress
 */
export interface SingleLineAddress {
  /**
   * The entire address in one string (e.g., \"210 King Street 94107\"). _Does not support a recipient and will error when other payload parameters are provided._
   * @type {string}
   * @memberof SingleLineAddress
   */
  address?: string;
}
/**
 *
 * @export
 * @interface SortBy
 */
export interface SortBy {
  /**
   *
   * @type {string}
   * @memberof SortBy
   */
  date_created?: SortByDateCreatedEnum;
  /**
   *
   * @type {string}
   * @memberof SortBy
   */
  send_date?: SortBySendDateEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SortByDateCreatedEnum {
  Asc = "asc",
  Desc = "desc",
}
/**
 * @export
 * @enum {string}
 */
export enum SortBySendDateEnum {
  Asc = "asc",
  Desc = "desc",
}

/**
 *
 * @export
 * @interface SortBy1
 */
export interface SortBy1 {
  /**
   *
   * @type {string}
   * @memberof SortBy1
   */
  date_created?: SortBy1DateCreatedEnum;
  /**
   *
   * @type {string}
   * @memberof SortBy1
   */
  send_date?: SortBy1SendDateEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SortBy1DateCreatedEnum {
  Asc = "asc",
  Desc = "desc",
}
/**
 * @export
 * @enum {string}
 */
export enum SortBy1SendDateEnum {
  Asc = "asc",
  Desc = "desc",
}

/**
 *
 * @export
 * @interface SortBy2
 */
export interface SortBy2 {
  /**
   *
   * @type {string}
   * @memberof SortBy2
   */
  date_created?: SortBy2DateCreatedEnum;
  /**
   *
   * @type {string}
   * @memberof SortBy2
   */
  send_date?: SortBy2SendDateEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SortBy2DateCreatedEnum {
  Asc = "asc",
  Desc = "desc",
}
/**
 * @export
 * @enum {string}
 */
export enum SortBy2SendDateEnum {
  Asc = "asc",
  Desc = "desc",
}

/**
 *
 * @export
 * @interface Thumbnail
 */
export interface Thumbnail {
  /**
   * A [signed link](#section/Asset-URLs) served over HTTPS. The link returned will expire in 30 days to prevent mis-sharing. Each time a GET request is initiated, a new signed URL will be generated.
   * @type {string}
   * @memberof Thumbnail
   */
  small?: string;
  /**
   * A [signed link](#section/Asset-URLs) served over HTTPS. The link returned will expire in 30 days to prevent mis-sharing. Each time a GET request is initiated, a new signed URL will be generated.
   * @type {string}
   * @memberof Thumbnail
   */
  medium?: string;
  /**
   * A [signed link](#section/Asset-URLs) served over HTTPS. The link returned will expire in 30 days to prevent mis-sharing. Each time a GET request is initiated, a new signed URL will be generated.
   * @type {string}
   * @memberof Thumbnail
   */
  large?: string;
}
/**
 * As mail pieces travel through the mail stream, USPS scans their unique barcodes, and Lob processes these mail scans to generate tracking events.
 * @export
 * @interface TrackingEventBase
 */
export interface TrackingEventBase {
  /**
   * Unique identifier prefixed with `evnt_`.
   * @type {string}
   * @memberof TrackingEventBase
   */
  id: string;
  /**
   * A timestamp in ISO 8601 format of the date USPS registered the event.
   * @type {string}
   * @memberof TrackingEventBase
   */
  time?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof TrackingEventBase
   */
  date_created: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was last modified.
   * @type {string}
   * @memberof TrackingEventBase
   */
  date_modified: string;
  /**
   *
   * @type {string}
   * @memberof TrackingEventBase
   */
  object: string;
}
/**
 *
 * @export
 * @interface TrackingEventNormal
 */
export interface TrackingEventNormal {
  /**
   * Unique identifier prefixed with `evnt_`.
   * @type {string}
   * @memberof TrackingEventNormal
   */
  id: string;
  /**
   * A timestamp in ISO 8601 format of the date USPS registered the event.
   * @type {string}
   * @memberof TrackingEventNormal
   */
  time?: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was created.
   * @type {string}
   * @memberof TrackingEventNormal
   */
  date_created: string;
  /**
   * A timestamp in ISO 8601 format of the date the resource was last modified.
   * @type {string}
   * @memberof TrackingEventNormal
   */
  date_modified: string;
  /**
   *
   * @type {string}
   * @memberof TrackingEventNormal
   */
  object: string;
  /**
   * non-Certified postcards, self mailers, letters, and checks
   * @type {string}
   * @memberof TrackingEventNormal
   */
  type: TrackingEventNormalTypeEnum;
  /**
   * Name of tracking event (for normal postcards, self mailers, letters, and checks):    * `In Transit` - The mailpiece is being processed at the entry/origin facility.    * `In Local Area` - The mailpiece is being processed at the destination facility.    * `Processed for Delivery` - The mailpiece has been greenlit for     delivery at the recipient\'s nearest postal facility. The mailpiece     should reach the mailbox within 1 business day of this tracking     event.    * `Re-Routed` - The mailpiece is re-routed due to recipient change of     address, address errors, or USPS relabeling of barcode/ID tag     area.    * `Returned to Sender` - The mailpiece is being returned to sender due     to barcode, ID tag area, or address errors.    * `Mailed` - The mailpiece has been handed off to and accepted by USPS     and is en route. [More about     Mailed.](https://support.lob.com/hc/en-us/articles/360001724400-What-does-a-Mailed-tracking-event-mean-)     Note this data is only available in Enterprise editions of     Lob. [Contact Sales](https://lob.com/support/contact#contact) if     you want access to this feature.  [More about tracking](https://support.lob.com/hc/en-us/articles/115000097404-Can-I-track-my-mail-)
   * @type {string}
   * @memberof TrackingEventNormal
   */
  name: TrackingEventNormalNameEnum;
  /**
   * Will be `null` for `type=normal` events
   * @type {object}
   * @memberof TrackingEventNormal
   */
  details?: TrackingEventNormalDetailsEnum;
  /**
   * The zip code in which the scan event occurred. Null for `Mailed` events.
   * @type {string}
   * @memberof TrackingEventNormal
   */
  location?: string | null;
}

/**
 * @export
 * @enum {string}
 */
export enum TrackingEventNormalTypeEnum {
  Normal = "normal",
}
/**
 * @export
 * @enum {string}
 */
export enum TrackingEventNormalNameEnum {
  InTransit = "In Transit",
  InLocalArea = "In Local Area",
  ProcessedForDelivery = "Processed for Delivery",
  ReRouted = "Re-Routed",
  ReturnedToSender = "Returned to Sender",
  Mailed = "Mailed",
}
/**
 * @export
 * @enum {string}
 */
export enum TrackingEventNormalDetailsEnum {
  Null = "null",
}

/**
 *
 * @export
 * @interface TrackingEventNormalAllOf
 */
export interface TrackingEventNormalAllOf {
  /**
   * non-Certified postcards, self mailers, letters, and checks
   * @type {string}
   * @memberof TrackingEventNormalAllOf
   */
  type: TrackingEventNormalAllOfTypeEnum;
  /**
   * Name of tracking event (for normal postcards, self mailers, letters, and checks):    * `In Transit` - The mailpiece is being processed at the entry/origin facility.    * `In Local Area` - The mailpiece is being processed at the destination facility.    * `Processed for Delivery` - The mailpiece has been greenlit for     delivery at the recipient\'s nearest postal facility. The mailpiece     should reach the mailbox within 1 business day of this tracking     event.    * `Re-Routed` - The mailpiece is re-routed due to recipient change of     address, address errors, or USPS relabeling of barcode/ID tag     area.    * `Returned to Sender` - The mailpiece is being returned to sender due     to barcode, ID tag area, or address errors.    * `Mailed` - The mailpiece has been handed off to and accepted by USPS     and is en route. [More about     Mailed.](https://support.lob.com/hc/en-us/articles/360001724400-What-does-a-Mailed-tracking-event-mean-)     Note this data is only available in Enterprise editions of     Lob. [Contact Sales](https://lob.com/support/contact#contact) if     you want access to this feature.  [More about tracking](https://support.lob.com/hc/en-us/articles/115000097404-Can-I-track-my-mail-)
   * @type {string}
   * @memberof TrackingEventNormalAllOf
   */
  name: TrackingEventNormalAllOfNameEnum;
  /**
   * Will be `null` for `type=normal` events
   * @type {object}
   * @memberof TrackingEventNormalAllOf
   */
  details?: TrackingEventNormalAllOfDetailsEnum;
  /**
   * The zip code in which the scan event occurred. Null for `Mailed` events.
   * @type {string}
   * @memberof TrackingEventNormalAllOf
   */
  location?: string | null;
}

/**
 * @export
 * @enum {string}
 */
export enum TrackingEventNormalAllOfTypeEnum {
  Normal = "normal",
}
/**
 * @export
 * @enum {string}
 */
export enum TrackingEventNormalAllOfNameEnum {
  InTransit = "In Transit",
  InLocalArea = "In Local Area",
  ProcessedForDelivery = "Processed for Delivery",
  ReRouted = "Re-Routed",
  ReturnedToSender = "Returned to Sender",
  Mailed = "Mailed",
}
/**
 * @export
 * @enum {string}
 */
export enum TrackingEventNormalAllOfDetailsEnum {
  Null = "null",
}

/**
 * A nested object containing a breakdown of each component of an address.
 * @export
 * @interface UsComponents
 */
export interface UsComponents {
  /**
   * The numeric or alphanumeric part of an address preceding the street name. Often the house, building, or PO Box number.
   * @type {string}
   * @memberof UsComponents
   */
  primary_number?: string;
  /**
   * Geographic direction preceding a street name (`N`, `S`, `E`, `W`, `NE`, `SW`, `SE`, `NW`).
   * @type {string}
   * @memberof UsComponents
   */
  street_predirection?: UsComponentsStreetPredirectionEnum;
  /**
   * The name of the street.
   * @type {string}
   * @memberof UsComponents
   */
  street_name?: string;
  /**
   * The standard USPS abbreviation for the street suffix (`ST`, `AVE`, `BLVD`, etc).
   * @type {string}
   * @memberof UsComponents
   */
  street_suffix?: string;
  /**
   * Geographic direction following a street name (`N`, `S`, `E`, `W`, `NE`, `SW`, `SE`, `NW`).
   * @type {string}
   * @memberof UsComponents
   */
  street_postdirection?: UsComponentsStreetPostdirectionEnum;
  /**
   * The standard USPS abbreviation describing the `components[secondary_number]` (`STE`, `APT`, `BLDG`, etc).
   * @type {string}
   * @memberof UsComponents
   */
  secondary_designator?: string;
  /**
   * Number of the apartment/unit/etc.
   * @type {string}
   * @memberof UsComponents
   */
  secondary_number?: string;
  /**
   * Designator of a [CMRA-authorized](https://en.wikipedia.org/wiki/Commercial_mail_receiving_agency) private mailbox.
   * @type {string}
   * @memberof UsComponents
   */
  pmb_designator?: string;
  /**
   * Number of a [CMRA-authorized](https://en.wikipedia.org/wiki/Commercial_mail_receiving_agency) private mailbox.
   * @type {string}
   * @memberof UsComponents
   */
  pmb_number?: string;
  /**
   * An extra (often unnecessary) secondary designator provided with the input address.
   * @type {string}
   * @memberof UsComponents
   */
  extra_secondary_designator?: string;
  /**
   * An extra (often unnecessary) secondary number provided with the input address.
   * @type {string}
   * @memberof UsComponents
   */
  extra_secondary_number?: string;
  /**
   *
   * @type {string}
   * @memberof UsComponents
   */
  city?: string;
  /**
   * The [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) two letter code for the state.
   * @type {string}
   * @memberof UsComponents
   */
  state?: string;
  /**
   * The 5-digit ZIP code
   * @type {string}
   * @memberof UsComponents
   */
  zip_code?: string;
  /**
   *
   * @type {string}
   * @memberof UsComponents
   */
  zip_code_plus_4?: string;
  /**
   *
   * @type {ZipCodeType}
   * @memberof UsComponents
   */
  zip_code_type?: ZipCodeType;
  /**
   * A 12-digit identifier that uniquely identifies a delivery point (location where mail can be sent and received). It consists of the 5-digit ZIP code (`zip_code`), 4-digit ZIP+4 add-on (`zip_code_plus_4`), 2-digit delivery point, and 1-digit delivery point check digit.
   * @type {string}
   * @memberof UsComponents
   */
  delivery_point_barcode?: string;
  /**
   * Uses USPS\'s [Residential Delivery Indicator (RDI)](https://www.usps.com/nationalpremieraccounts/rdi.htm) to identify whether an address is classified as residential or business. Possible values are: * `residential` –– The address is residential or a PO Box. * `commercial` –– The address is commercial. * `\'\'` –– Not enough information provided to be determined.
   * @type {string}
   * @memberof UsComponents
   */
  address_type?: UsComponentsAddressTypeEnum;
  /**
   * A description of the type of address. Populated if a DPV match is made (`deliverability_analysis[dpv_confirmation]` is `Y`, `S`, or `D`). For more detailed information about each record type, see [US Verification Details](#tag/US-Verification-Types).
   * @type {string}
   * @memberof UsComponents
   */
  record_type?: UsComponentsRecordTypeEnum;
  /**
   * Designates whether or not the address is the default address for a building containing multiple delivery points.
   * @type {boolean}
   * @memberof UsComponents
   */
  default_building_address?: boolean;
  /**
   * County name of the address city.
   * @type {string}
   * @memberof UsComponents
   */
  county?: string;
  /**
   * A 5-digit [FIPS county code](https://en.wikipedia.org/wiki/FIPS_county_code) which uniquely identifies `components[county]`. It consists of a 2-digit state code and a 3-digit county code.
   * @type {string}
   * @memberof UsComponents
   */
  county_fips?: string;
  /**
   * A 4-character code assigned to a mail delivery route within a ZIP code.
   * @type {string}
   * @memberof UsComponents
   */
  carrier_route?: string;
  /**
   * The type of `components[carrier_route]`. For more detailed information about each carrier route type, see [US Verification Details](#tag/US-Verification-Types).
   * @type {string}
   * @memberof UsComponents
   */
  carrier_route_type?: UsComponentsCarrierRouteTypeEnum;
  /**
   * A positive or negative decimal indicating the geographic latitude of the address, specifying the north-to-south position of a location. This should be used with `longitude` to pinpoint locations on a map. Will not be returned for undeliverable addresses or military addresses (state is `AA`, `AE`, or `AP`).
   * @type {number}
   * @memberof UsComponents
   */
  latitude?: number | null;
  /**
   * A positive or negative decimal indicating the geographic longitude of the address, specifying the north-to-south position of a location. This should be used with `latitude` to pinpoint locations on a map. Will not be returned for undeliverable addresses or military addresses (state is `AA`, `AE`, or `AP`).
   * @type {number}
   * @memberof UsComponents
   */
  longitude?: number | null;
}

/**
 * @export
 * @enum {string}
 */
export enum UsComponentsStreetPredirectionEnum {
  N = "N",
  S = "S",
  E = "E",
  W = "W",
  Ne = "NE",
  Sw = "SW",
  Se = "SE",
  Nw = "NW",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum UsComponentsStreetPostdirectionEnum {
  N = "N",
  S = "S",
  E = "E",
  W = "W",
  Ne = "NE",
  Sw = "SW",
  Se = "SE",
  Nw = "NW",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum UsComponentsAddressTypeEnum {
  Residential = "residential",
  Commercial = "commercial",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum UsComponentsRecordTypeEnum {
  Street = "street",
  Highrise = "highrise",
  Firm = "firm",
  PoBox = "po_box",
  RuralRoute = "rural_route",
  GeneralDelivery = "general_delivery",
  Empty = "",
}
/**
 * @export
 * @enum {string}
 */
export enum UsComponentsCarrierRouteTypeEnum {
  CityDelivery = "city_delivery",
  RuralRoute = "rural_route",
  HighwayContract = "highway_contract",
  PoBox = "po_box",
  GeneralDelivery = "general_delivery",
}

/**
 *
 * @export
 * @interface UsVerification
 */
export interface UsVerification {
  /**
   * Unique identifier prefixed with `us_ver_`.
   * @type {string}
   * @memberof UsVerification
   */
  id?: string;
  /**
   * The intended recipient, typically a person\'s or firm\'s name.
   * @type {string}
   * @memberof UsVerification
   */
  recipient?: string | null;
  /**
   * The primary delivery line (usually the street address) of the address. Combination of the following applicable `components`: * `primary_number` * `street_predirection` * `street_name` * `street_suffix` * `street_postdirection` * `secondary_designator` * `secondary_number` * `pmb_designator` * `pmb_number`
   * @type {string}
   * @memberof UsVerification
   */
  primary_line?: string;
  /**
   * The secondary delivery line of the address. This field is typically empty but may contain information if `primary_line` is too long.
   * @type {string}
   * @memberof UsVerification
   */
  secondary_line?: string;
  /**
   * Only present for addresses in Puerto Rico. An urbanization refers to an area, sector, or development within a city. See [USPS documentation](https://pe.usps.com/text/pub28/28api_008.htm#:~:text=I51.,-4%20Urbanizations&text=In%20Puerto%20Rico%2C%20identical%20street,placed%20before%20the%20urbanization%20name.) for clarification.
   * @type {string}
   * @memberof UsVerification
   */
  urbanization?: string;
  /**
   * Combination of the following applicable `components`: * City (`city`) * State (`state`) * ZIP code (`zip_code`) * ZIP+4 (`zip_code_plus_4`)
   * @type {string}
   * @memberof UsVerification
   */
  last_line?: string;
  /**
   * Summarizes the deliverability of the `us_verification` object. For full details, see the `deliverability_analysis` field. Possible values are: * `deliverable` – The address is deliverable by the USPS. * `deliverable_unnecessary_unit` – The address is deliverable, but the secondary unit information is unnecessary. * `deliverable_incorrect_unit` – The address is deliverable to the building\'s default address but the secondary unit provided may not exist. There is a chance the mail will not reach the intended recipient. * `deliverable_missing_unit` – The address is deliverable to the building\'s default address but is missing secondary unit information. There is a chance the mail will not reach the intended recipient. * `undeliverable` – The address is not deliverable according to the USPS.
   * @type {string}
   * @memberof UsVerification
   */
  deliverability?: UsVerificationDeliverabilityEnum;
  /**
   *
   * @type {UsComponents}
   * @memberof UsVerification
   */
  components?: UsComponents;
  /**
   *
   * @type {DeliverabilityAnalysis}
   * @memberof UsVerification
   */
  deliverability_analysis?: DeliverabilityAnalysis;
  /**
   *
   * @type {LobConfidenceScore}
   * @memberof UsVerification
   */
  lob_confidence_score?: LobConfidenceScore;
  /**
   *
   * @type {string}
   * @memberof UsVerification
   */
  object?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum UsVerificationDeliverabilityEnum {
  Deliverable = "deliverable",
  DeliverableUnnecessaryUnit = "deliverable_unnecessary_unit",
  DeliverableIncorrectUnit = "deliverable_incorrect_unit",
  DeliverableMissingUnit = "deliverable_missing_unit",
  Undeliverable = "undeliverable",
}

/**
 * @type UsVerificationsWritable
 * @export
 */
export type UsVerificationsWritable = MultipleComponents | SingleLineAddress;

/**
 * A description of the ZIP code type. For more detailed information about each ZIP code type, see [US Verification Details](#tag/US-Verification-Types).
 * @export
 * @enum {string}
 */

export enum ZipCodeType {
  Standard = "standard",
  PoBox = "po_box",
  Unique = "unique",
  Military = "military",
  Empty = "",
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new address given information
     * @summary Create
     * @param {AddressEditable} addressEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAddress: async (
      addressEditable: AddressEditable,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'addressEditable' is not null or undefined
      assertParamExists("createAddress", "addressEditable", addressEditable);
      const localVarPath = `/addresses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addressEditable,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes the details of an existing address. You need only supply the unique identifier that was returned upon address creation.
     * @summary Delete
     * @param {string} adrId id of the address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress: async (
      adrId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adrId' is not null or undefined
      assertParamExists("deleteAddress", "adrId", adrId);
      const localVarPath = `/addresses/{adr_id}`.replace(
        `{${"adr_id"}}`,
        encodeURIComponent(String(adrId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of an existing address. You need only supply the unique identifier that was returned upon address creation.
     * @summary Retrieve
     * @param {string} adrId id of the address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress: async (
      adrId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'adrId' is not null or undefined
      assertParamExists("getAddress", "adrId", adrId);
      const localVarPath = `/addresses/{adr_id}`.replace(
        `{${"adr_id"}}`,
        encodeURIComponent(String(adrId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of your addresses. The addresses are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses: async (
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/addresses`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (before !== undefined) {
        localVarQueryParameter["before"] = before;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (dateCreated !== undefined) {
        localVarQueryParameter["date_created"] = dateCreated;
      }

      if (metadata !== undefined) {
        localVarQueryParameter["metadata"] = metadata;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    AddressesApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new address given information
     * @summary Create
     * @param {AddressEditable} addressEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAddress(
      addressEditable: AddressEditable,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(
        addressEditable,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Deletes the details of an existing address. You need only supply the unique identifier that was returned upon address creation.
     * @summary Delete
     * @param {string} adrId id of the address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAddress(
      adrId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AddressDeletion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddress(
        adrId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves the details of an existing address. You need only supply the unique identifier that was returned upon address creation.
     * @summary Retrieve
     * @param {string} adrId id of the address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddress(
      adrId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(
        adrId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of your addresses. The addresses are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAddresses(
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(
        limit,
        before,
        after,
        include,
        dateCreated,
        metadata,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AddressesApiFp(configuration);
  return {
    /**
     * Creates a new address given information
     * @summary Create
     * @param {AddressEditable} addressEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAddress(
      addressEditable: AddressEditable,
      options?: any
    ): AxiosPromise<Address> {
      return localVarFp
        .createAddress(addressEditable, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes the details of an existing address. You need only supply the unique identifier that was returned upon address creation.
     * @summary Delete
     * @param {string} adrId id of the address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress(adrId: string, options?: any): AxiosPromise<AddressDeletion> {
      return localVarFp
        .deleteAddress(adrId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of an existing address. You need only supply the unique identifier that was returned upon address creation.
     * @summary Retrieve
     * @param {string} adrId id of the address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddress(adrId: string, options?: any): AxiosPromise<Address> {
      return localVarFp
        .getAddress(adrId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of your addresses. The addresses are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAddresses(
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      options?: any
    ): AxiosPromise<AddressList> {
      return localVarFp
        .listAddresses(
          limit,
          before,
          after,
          include,
          dateCreated,
          metadata,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
  /**
   * Creates a new address given information
   * @summary Create
   * @param {AddressEditable} addressEditable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public createAddress(
    addressEditable: AddressEditable,
    options?: AxiosRequestConfig
  ) {
    return AddressesApiFp(this.configuration)
      .createAddress(addressEditable, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Deletes the details of an existing address. You need only supply the unique identifier that was returned upon address creation.
   * @summary Delete
   * @param {string} adrId id of the address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public deleteAddress(adrId: string, options?: AxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .deleteAddress(adrId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Retrieves the details of an existing address. You need only supply the unique identifier that was returned upon address creation.
   * @summary Retrieve
   * @param {string} adrId id of the address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public getAddress(adrId: string, options?: AxiosRequestConfig) {
    return AddressesApiFp(this.configuration)
      .getAddress(adrId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Returns a list of your addresses. The addresses are returned sorted by creation date, with the most recently created addresses appearing first.
   * @summary List
   * @param {number} [limit] How many results to return.
   * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
   * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
   * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
   * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
   * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public listAddresses(
    limit?: number,
    before?: string,
    after?: string,
    include?: { [key: string]: string },
    dateCreated?: { [key: string]: string },
    metadata?: { [key: string]: string },
    options?: AxiosRequestConfig
  ) {
    return AddressesApiFp(this.configuration)
      .listAddresses(
        limit,
        before,
        after,
        include,
        dateCreated,
        metadata,
        options
      )
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }
}

/**
 * BankAccountsApi - axios parameter creator
 * @export
 */
export const BankAccountsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new bank account with the provided properties. Bank accounts created in live mode will need to be verified via micro deposits before being able to send live checks. The deposits will appear in the bank account in 2-3 business days and have the description \"VERIFICATION\".
     * @summary Create
     * @param {BankAccountWritable} bankAccountWritable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountCreate: async (
      bankAccountWritable: BankAccountWritable,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bankAccountWritable' is not null or undefined
      assertParamExists(
        "bankAccountCreate",
        "bankAccountWritable",
        bankAccountWritable
      );
      const localVarPath = `/bank_accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bankAccountWritable,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Permanently deletes a bank account. It cannot be undone.
     * @summary Delete
     * @param {string} bankId id of the bank account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountDelete: async (
      bankId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bankId' is not null or undefined
      assertParamExists("bankAccountDelete", "bankId", bankId);
      const localVarPath = `/bank_accounts/{bank_id}`.replace(
        `{${"bank_id"}}`,
        encodeURIComponent(String(bankId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of an existing bank account. You need only supply the unique bank account identifier that was returned upon bank account creation.
     * @summary Retrieve
     * @param {string} bankId id of the bank account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountRetrieve: async (
      bankId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bankId' is not null or undefined
      assertParamExists("bankAccountRetrieve", "bankId", bankId);
      const localVarPath = `/bank_accounts/{bank_id}`.replace(
        `{${"bank_id"}}`,
        encodeURIComponent(String(bankId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Verify a bank account in order to create a check.
     * @summary Verify
     * @param {string} bankId id of the bank account to be verified
     * @param {BankAccountVerify} bankAccountVerify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountVerify: async (
      bankId: string,
      bankAccountVerify: BankAccountVerify,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'bankId' is not null or undefined
      assertParamExists("bankAccountVerify", "bankId", bankId);
      // verify required parameter 'bankAccountVerify' is not null or undefined
      assertParamExists(
        "bankAccountVerify",
        "bankAccountVerify",
        bankAccountVerify
      );
      const localVarPath = `/bank_accounts/{bank_id}/verify`.replace(
        `{${"bank_id"}}`,
        encodeURIComponent(String(bankId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bankAccountVerify,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of your bank accounts. The bank accounts are returned sorted by creation date, with the most recently created bank accounts appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountsList: async (
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/bank_accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (before !== undefined) {
        localVarQueryParameter["before"] = before;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (dateCreated !== undefined) {
        localVarQueryParameter["date_created"] = dateCreated;
      }

      if (metadata !== undefined) {
        localVarQueryParameter["metadata"] = metadata;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BankAccountsApi - functional programming interface
 * @export
 */
export const BankAccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    BankAccountsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new bank account with the provided properties. Bank accounts created in live mode will need to be verified via micro deposits before being able to send live checks. The deposits will appear in the bank account in 2-3 business days and have the description \"VERIFICATION\".
     * @summary Create
     * @param {BankAccountWritable} bankAccountWritable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bankAccountCreate(
      bankAccountWritable: BankAccountWritable,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccount>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bankAccountCreate(
          bankAccountWritable,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Permanently deletes a bank account. It cannot be undone.
     * @summary Delete
     * @param {string} bankId id of the bank account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bankAccountDelete(
      bankId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BankAccountDeletion>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bankAccountDelete(bankId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves the details of an existing bank account. You need only supply the unique bank account identifier that was returned upon bank account creation.
     * @summary Retrieve
     * @param {string} bankId id of the bank account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bankAccountRetrieve(
      bankId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccount>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bankAccountRetrieve(bankId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Verify a bank account in order to create a check.
     * @summary Verify
     * @param {string} bankId id of the bank account to be verified
     * @param {BankAccountVerify} bankAccountVerify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bankAccountVerify(
      bankId: string,
      bankAccountVerify: BankAccountVerify,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccount>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bankAccountVerify(
          bankId,
          bankAccountVerify,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of your bank accounts. The bank accounts are returned sorted by creation date, with the most recently created bank accounts appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bankAccountsList(
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<BankAccountList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bankAccountsList(
          limit,
          before,
          after,
          include,
          dateCreated,
          metadata,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * BankAccountsApi - factory interface
 * @export
 */
export const BankAccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BankAccountsApiFp(configuration);
  return {
    /**
     * Creates a new bank account with the provided properties. Bank accounts created in live mode will need to be verified via micro deposits before being able to send live checks. The deposits will appear in the bank account in 2-3 business days and have the description \"VERIFICATION\".
     * @summary Create
     * @param {BankAccountWritable} bankAccountWritable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountCreate(
      bankAccountWritable: BankAccountWritable,
      options?: any
    ): AxiosPromise<BankAccount> {
      return localVarFp
        .bankAccountCreate(bankAccountWritable, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Permanently deletes a bank account. It cannot be undone.
     * @summary Delete
     * @param {string} bankId id of the bank account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountDelete(
      bankId: string,
      options?: any
    ): AxiosPromise<BankAccountDeletion> {
      return localVarFp
        .bankAccountDelete(bankId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of an existing bank account. You need only supply the unique bank account identifier that was returned upon bank account creation.
     * @summary Retrieve
     * @param {string} bankId id of the bank account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountRetrieve(
      bankId: string,
      options?: any
    ): AxiosPromise<BankAccount> {
      return localVarFp
        .bankAccountRetrieve(bankId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Verify a bank account in order to create a check.
     * @summary Verify
     * @param {string} bankId id of the bank account to be verified
     * @param {BankAccountVerify} bankAccountVerify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountVerify(
      bankId: string,
      bankAccountVerify: BankAccountVerify,
      options?: any
    ): AxiosPromise<BankAccount> {
      return localVarFp
        .bankAccountVerify(bankId, bankAccountVerify, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of your bank accounts. The bank accounts are returned sorted by creation date, with the most recently created bank accounts appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bankAccountsList(
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      options?: any
    ): AxiosPromise<BankAccountList> {
      return localVarFp
        .bankAccountsList(
          limit,
          before,
          after,
          include,
          dateCreated,
          metadata,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BankAccountsApi - object-oriented interface
 * @export
 * @class BankAccountsApi
 * @extends {BaseAPI}
 */
export class BankAccountsApi extends BaseAPI {
  /**
   * Creates a new bank account with the provided properties. Bank accounts created in live mode will need to be verified via micro deposits before being able to send live checks. The deposits will appear in the bank account in 2-3 business days and have the description \"VERIFICATION\".
   * @summary Create
   * @param {BankAccountWritable} bankAccountWritable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankAccountsApi
   */
  public bankAccountCreate(
    bankAccountWritable: BankAccountWritable,
    options?: AxiosRequestConfig
  ) {
    return BankAccountsApiFp(this.configuration)
      .bankAccountCreate(bankAccountWritable, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Permanently deletes a bank account. It cannot be undone.
   * @summary Delete
   * @param {string} bankId id of the bank account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankAccountsApi
   */
  public bankAccountDelete(bankId: string, options?: AxiosRequestConfig) {
    return BankAccountsApiFp(this.configuration)
      .bankAccountDelete(bankId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Retrieves the details of an existing bank account. You need only supply the unique bank account identifier that was returned upon bank account creation.
   * @summary Retrieve
   * @param {string} bankId id of the bank account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankAccountsApi
   */
  public bankAccountRetrieve(bankId: string, options?: AxiosRequestConfig) {
    return BankAccountsApiFp(this.configuration)
      .bankAccountRetrieve(bankId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Verify a bank account in order to create a check.
   * @summary Verify
   * @param {string} bankId id of the bank account to be verified
   * @param {BankAccountVerify} bankAccountVerify
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankAccountsApi
   */
  public bankAccountVerify(
    bankId: string,
    bankAccountVerify: BankAccountVerify,
    options?: AxiosRequestConfig
  ) {
    return BankAccountsApiFp(this.configuration)
      .bankAccountVerify(bankId, bankAccountVerify, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Returns a list of your bank accounts. The bank accounts are returned sorted by creation date, with the most recently created bank accounts appearing first.
   * @summary List
   * @param {number} [limit] How many results to return.
   * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
   * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
   * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
   * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
   * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankAccountsApi
   */
  public bankAccountsList(
    limit?: number,
    before?: string,
    after?: string,
    include?: { [key: string]: string },
    dateCreated?: { [key: string]: string },
    metadata?: { [key: string]: string },
    options?: AxiosRequestConfig
  ) {
    return BankAccountsApiFp(this.configuration)
      .bankAccountsList(
        limit,
        before,
        after,
        include,
        dateCreated,
        metadata,
        options
      )
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }
}

/**
 * CardOrdersApi - axios parameter creator
 * @export
 */
export const CardOrdersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new card order given information
     * @summary Create
     * @param {string} cardId The ID of the card to which the card orders belong.
     * @param {CardOrderEditable} cardOrderEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardOrderCreate: async (
      cardId: string,
      cardOrderEditable: CardOrderEditable,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("cardOrderCreate", "cardId", cardId);
      // verify required parameter 'cardOrderEditable' is not null or undefined
      assertParamExists(
        "cardOrderCreate",
        "cardOrderEditable",
        cardOrderEditable
      );
      const localVarPath = `/cards/{card_id}/orders`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cardOrderEditable,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the card orders associated with the given card id.
     * @summary Retrieve
     * @param {string} cardId The ID of the card to which the card orders belong.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardOrdersRetrieve: async (
      cardId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("cardOrdersRetrieve", "cardId", cardId);
      const localVarPath = `/cards/{card_id}/orders`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CardOrdersApi - functional programming interface
 * @export
 */
export const CardOrdersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CardOrdersApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new card order given information
     * @summary Create
     * @param {string} cardId The ID of the card to which the card orders belong.
     * @param {CardOrderEditable} cardOrderEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cardOrderCreate(
      cardId: string,
      cardOrderEditable: CardOrderEditable,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardOrder>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cardOrderCreate(
        cardId,
        cardOrderEditable,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves the card orders associated with the given card id.
     * @summary Retrieve
     * @param {string} cardId The ID of the card to which the card orders belong.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cardOrdersRetrieve(
      cardId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cardOrdersRetrieve(cardId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CardOrdersApi - factory interface
 * @export
 */
export const CardOrdersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CardOrdersApiFp(configuration);
  return {
    /**
     * Creates a new card order given information
     * @summary Create
     * @param {string} cardId The ID of the card to which the card orders belong.
     * @param {CardOrderEditable} cardOrderEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardOrderCreate(
      cardId: string,
      cardOrderEditable: CardOrderEditable,
      options?: any
    ): AxiosPromise<CardOrder> {
      return localVarFp
        .cardOrderCreate(cardId, cardOrderEditable, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the card orders associated with the given card id.
     * @summary Retrieve
     * @param {string} cardId The ID of the card to which the card orders belong.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardOrdersRetrieve(
      cardId: string,
      options?: any
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .cardOrdersRetrieve(cardId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CardOrdersApi - object-oriented interface
 * @export
 * @class CardOrdersApi
 * @extends {BaseAPI}
 */
export class CardOrdersApi extends BaseAPI {
  /**
   * Creates a new card order given information
   * @summary Create
   * @param {string} cardId The ID of the card to which the card orders belong.
   * @param {CardOrderEditable} cardOrderEditable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardOrdersApi
   */
  public cardOrderCreate(
    cardId: string,
    cardOrderEditable: CardOrderEditable,
    options?: AxiosRequestConfig
  ) {
    return CardOrdersApiFp(this.configuration)
      .cardOrderCreate(cardId, cardOrderEditable, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Retrieves the card orders associated with the given card id.
   * @summary Retrieve
   * @param {string} cardId The ID of the card to which the card orders belong.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardOrdersApi
   */
  public cardOrdersRetrieve(cardId: string, options?: AxiosRequestConfig) {
    return CardOrdersApiFp(this.configuration)
      .cardOrdersRetrieve(cardId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }
}

/**
 * CardsApi - axios parameter creator
 * @export
 */
export const CardsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new card given information
     * @summary Create
     * @param {CardEditable} cardEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardCreate: async (
      cardEditable: CardEditable,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardEditable' is not null or undefined
      assertParamExists("cardCreate", "cardEditable", cardEditable);
      const localVarPath = `/cards`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cardEditable,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete an existing card. You need only supply the unique identifier that was returned upon card creation.
     * @summary Delete
     * @param {string} cardId id of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardDelete: async (
      cardId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("cardDelete", "cardId", cardId);
      const localVarPath = `/cards/{card_id}`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of an existing card. You need only supply the unique customer identifier that was returned upon card creation.
     * @summary Retrieve
     * @param {string} cardId id of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardRetrieve: async (
      cardId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("cardRetrieve", "cardId", cardId);
      const localVarPath = `/cards/{card_id}`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update the details of an existing card. You need only supply the unique identifier that was returned upon card creation.
     * @summary Update
     * @param {string} cardId id of the card
     * @param {CardUpdatable} cardUpdatable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardUpdate: async (
      cardId: string,
      cardUpdatable: CardUpdatable,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'cardId' is not null or undefined
      assertParamExists("cardUpdate", "cardId", cardId);
      // verify required parameter 'cardUpdatable' is not null or undefined
      assertParamExists("cardUpdate", "cardUpdatable", cardUpdatable);
      const localVarPath = `/cards/{card_id}`.replace(
        `{${"card_id"}}`,
        encodeURIComponent(String(cardId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        cardUpdatable,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of your cards. The cards are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardsList: async (
      limit?: number,
      before?: string,
      after?: string,
      sortBy?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/cards`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (before !== undefined) {
        localVarQueryParameter["before"] = before;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CardsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new card given information
     * @summary Create
     * @param {CardEditable} cardEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cardCreate(
      cardEditable: CardEditable,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Card>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cardCreate(
        cardEditable,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete an existing card. You need only supply the unique identifier that was returned upon card creation.
     * @summary Delete
     * @param {string} cardId id of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cardDelete(
      cardId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardDeletion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cardDelete(
        cardId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves the details of an existing card. You need only supply the unique customer identifier that was returned upon card creation.
     * @summary Retrieve
     * @param {string} cardId id of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cardRetrieve(
      cardId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Card>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cardRetrieve(
        cardId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update the details of an existing card. You need only supply the unique identifier that was returned upon card creation.
     * @summary Update
     * @param {string} cardId id of the card
     * @param {CardUpdatable} cardUpdatable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cardUpdate(
      cardId: string,
      cardUpdatable: CardUpdatable,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Card>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cardUpdate(
        cardId,
        cardUpdatable,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of your cards. The cards are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cardsList(
      limit?: number,
      before?: string,
      after?: string,
      sortBy?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cardsList(
        limit,
        before,
        after,
        sortBy,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CardsApiFp(configuration);
  return {
    /**
     * Creates a new card given information
     * @summary Create
     * @param {CardEditable} cardEditable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardCreate(cardEditable: CardEditable, options?: any): AxiosPromise<Card> {
      return localVarFp
        .cardCreate(cardEditable, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete an existing card. You need only supply the unique identifier that was returned upon card creation.
     * @summary Delete
     * @param {string} cardId id of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardDelete(cardId: string, options?: any): AxiosPromise<CardDeletion> {
      return localVarFp
        .cardDelete(cardId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of an existing card. You need only supply the unique customer identifier that was returned upon card creation.
     * @summary Retrieve
     * @param {string} cardId id of the card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardRetrieve(cardId: string, options?: any): AxiosPromise<Card> {
      return localVarFp
        .cardRetrieve(cardId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update the details of an existing card. You need only supply the unique identifier that was returned upon card creation.
     * @summary Update
     * @param {string} cardId id of the card
     * @param {CardUpdatable} cardUpdatable
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardUpdate(
      cardId: string,
      cardUpdatable: CardUpdatable,
      options?: any
    ): AxiosPromise<Card> {
      return localVarFp
        .cardUpdate(cardId, cardUpdatable, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of your cards. The cards are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardsList(
      limit?: number,
      before?: string,
      after?: string,
      sortBy?: object,
      options?: any
    ): AxiosPromise<CardList> {
      return localVarFp
        .cardsList(limit, before, after, sortBy, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI {
  /**
   * Creates a new card given information
   * @summary Create
   * @param {CardEditable} cardEditable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardsApi
   */
  public cardCreate(cardEditable: CardEditable, options?: AxiosRequestConfig) {
    return CardsApiFp(this.configuration)
      .cardCreate(cardEditable, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Delete an existing card. You need only supply the unique identifier that was returned upon card creation.
   * @summary Delete
   * @param {string} cardId id of the card
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardsApi
   */
  public cardDelete(cardId: string, options?: AxiosRequestConfig) {
    return CardsApiFp(this.configuration)
      .cardDelete(cardId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Retrieves the details of an existing card. You need only supply the unique customer identifier that was returned upon card creation.
   * @summary Retrieve
   * @param {string} cardId id of the card
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardsApi
   */
  public cardRetrieve(cardId: string, options?: AxiosRequestConfig) {
    return CardsApiFp(this.configuration)
      .cardRetrieve(cardId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Update the details of an existing card. You need only supply the unique identifier that was returned upon card creation.
   * @summary Update
   * @param {string} cardId id of the card
   * @param {CardUpdatable} cardUpdatable
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardsApi
   */
  public cardUpdate(
    cardId: string,
    cardUpdatable: CardUpdatable,
    options?: AxiosRequestConfig
  ) {
    return CardsApiFp(this.configuration)
      .cardUpdate(cardId, cardUpdatable, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Returns a list of your cards. The cards are returned sorted by creation date, with the most recently created addresses appearing first.
   * @summary List
   * @param {number} [limit] How many results to return.
   * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
   * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
   * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CardsApi
   */
  public cardsList(
    limit?: number,
    before?: string,
    after?: string,
    sortBy?: object,
    options?: AxiosRequestConfig
  ) {
    return CardsApiFp(this.configuration)
      .cardsList(limit, before, after, sortBy, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }
}

/**
 * LettersApi - axios parameter creator
 * @export
 */
export const LettersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Completely removes a letter from production. This can only be done if the letter has a `send_date` and the `send_date` has not yet passed. If the letter is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @summary Cancel
     * @param {string} ltrId id of the letter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    letterCancel: async (
      ltrId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ltrId' is not null or undefined
      assertParamExists("letterCancel", "ltrId", ltrId);
      const localVarPath = `/letters/{ltr_id}`.replace(
        `{${"ltr_id"}}`,
        encodeURIComponent(String(ltrId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new letter given information
     * @summary Create
     * @param {LetterEditable} letterEditable
     * @param {string} [idempotencyKey] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {string} [idempotencyKey2] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    letterCreate: async (
      letterEditable: LetterEditable,
      idempotencyKey?: string,
      idempotencyKey2?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'letterEditable' is not null or undefined
      assertParamExists("letterCreate", "letterEditable", letterEditable);
      const localVarPath = `/letters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (idempotencyKey2 !== undefined) {
        localVarQueryParameter["idempotency_key"] = idempotencyKey2;
      }

      if (idempotencyKey !== undefined && idempotencyKey !== null) {
        localVarHeaderParameter["Idempotency-Key"] = String(idempotencyKey);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        letterEditable,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of an existing letter. You need only supply the unique letter identifier that was returned upon letter creation.
     * @summary Retrieve
     * @param {string} ltrId id of the letter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    letterRetrieve: async (
      ltrId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'ltrId' is not null or undefined
      assertParamExists("letterRetrieve", "ltrId", ltrId);
      const localVarPath = `/letters/{ltr_id}`.replace(
        `{${"ltr_id"}}`,
        encodeURIComponent(String(ltrId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of your letters. The letters are returned sorted by creation date, with the most recently created letters appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {boolean} [color] Set to &#x60;true&#x60; to return only color letters. Set to &#x60;false&#x60; to return only black &amp; white letters.
     * @param {boolean} [scheduled] * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;
     * @param {SendDate} [sendDate] Filter by ISO-8601 date or datetime, e.g. &#x60;{ gt: \&#39;2012-01-01\&#39;, lt: \&#39;2012-01-31T12:34:56Z\&#39; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.
     * @param {MailType} [mailType] A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lettersList: async (
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      color?: boolean,
      scheduled?: boolean,
      sendDate?: SendDate,
      mailType?: MailType,
      sortBy?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/letters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (before !== undefined) {
        localVarQueryParameter["before"] = before;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (dateCreated !== undefined) {
        localVarQueryParameter["date_created"] = dateCreated;
      }

      if (metadata !== undefined) {
        localVarQueryParameter["metadata"] = metadata;
      }

      if (color !== undefined) {
        localVarQueryParameter["color"] = color;
      }

      if (scheduled !== undefined) {
        localVarQueryParameter["scheduled"] = scheduled;
      }

      if (sendDate !== undefined) {
        localVarQueryParameter["send_date"] = sendDate;
      }

      if (mailType !== undefined) {
        localVarQueryParameter["mail_type"] = mailType;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LettersApi - functional programming interface
 * @export
 */
export const LettersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LettersApiAxiosParamCreator(configuration);
  return {
    /**
     * Completely removes a letter from production. This can only be done if the letter has a `send_date` and the `send_date` has not yet passed. If the letter is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @summary Cancel
     * @param {string} ltrId id of the letter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async letterCancel(
      ltrId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LetterDeletion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.letterCancel(
        ltrId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Creates a new letter given information
     * @summary Create
     * @param {LetterEditable} letterEditable
     * @param {string} [idempotencyKey] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {string} [idempotencyKey2] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async letterCreate(
      letterEditable: LetterEditable,
      idempotencyKey?: string,
      idempotencyKey2?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Letter>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.letterCreate(
        letterEditable,
        idempotencyKey,
        idempotencyKey2,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves the details of an existing letter. You need only supply the unique letter identifier that was returned upon letter creation.
     * @summary Retrieve
     * @param {string} ltrId id of the letter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async letterRetrieve(
      ltrId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Letter>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.letterRetrieve(
        ltrId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of your letters. The letters are returned sorted by creation date, with the most recently created letters appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {boolean} [color] Set to &#x60;true&#x60; to return only color letters. Set to &#x60;false&#x60; to return only black &amp; white letters.
     * @param {boolean} [scheduled] * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;
     * @param {SendDate} [sendDate] Filter by ISO-8601 date or datetime, e.g. &#x60;{ gt: \&#39;2012-01-01\&#39;, lt: \&#39;2012-01-31T12:34:56Z\&#39; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.
     * @param {MailType} [mailType] A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async lettersList(
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      color?: boolean,
      scheduled?: boolean,
      sendDate?: SendDate,
      mailType?: MailType,
      sortBy?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LetterList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.lettersList(
        limit,
        before,
        after,
        include,
        dateCreated,
        metadata,
        color,
        scheduled,
        sendDate,
        mailType,
        sortBy,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LettersApi - factory interface
 * @export
 */
export const LettersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LettersApiFp(configuration);
  return {
    /**
     * Completely removes a letter from production. This can only be done if the letter has a `send_date` and the `send_date` has not yet passed. If the letter is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @summary Cancel
     * @param {string} ltrId id of the letter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    letterCancel(ltrId: string, options?: any): AxiosPromise<LetterDeletion> {
      return localVarFp
        .letterCancel(ltrId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new letter given information
     * @summary Create
     * @param {LetterEditable} letterEditable
     * @param {string} [idempotencyKey] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {string} [idempotencyKey2] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    letterCreate(
      letterEditable: LetterEditable,
      idempotencyKey?: string,
      idempotencyKey2?: string,
      options?: any
    ): AxiosPromise<Letter> {
      return localVarFp
        .letterCreate(letterEditable, idempotencyKey, idempotencyKey2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of an existing letter. You need only supply the unique letter identifier that was returned upon letter creation.
     * @summary Retrieve
     * @param {string} ltrId id of the letter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    letterRetrieve(ltrId: string, options?: any): AxiosPromise<Letter> {
      return localVarFp
        .letterRetrieve(ltrId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of your letters. The letters are returned sorted by creation date, with the most recently created letters appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {boolean} [color] Set to &#x60;true&#x60; to return only color letters. Set to &#x60;false&#x60; to return only black &amp; white letters.
     * @param {boolean} [scheduled] * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;
     * @param {SendDate} [sendDate] Filter by ISO-8601 date or datetime, e.g. &#x60;{ gt: \&#39;2012-01-01\&#39;, lt: \&#39;2012-01-31T12:34:56Z\&#39; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.
     * @param {MailType} [mailType] A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    lettersList(
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      color?: boolean,
      scheduled?: boolean,
      sendDate?: SendDate,
      mailType?: MailType,
      sortBy?: object,
      options?: any
    ): AxiosPromise<LetterList> {
      return localVarFp
        .lettersList(
          limit,
          before,
          after,
          include,
          dateCreated,
          metadata,
          color,
          scheduled,
          sendDate,
          mailType,
          sortBy,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LettersApi - object-oriented interface
 * @export
 * @class LettersApi
 * @extends {BaseAPI}
 */
export class LettersApi extends BaseAPI {
  /**
   * Completely removes a letter from production. This can only be done if the letter has a `send_date` and the `send_date` has not yet passed. If the letter is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
   * @summary Cancel
   * @param {string} ltrId id of the letter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LettersApi
   */
  public letterCancel(ltrId: string, options?: AxiosRequestConfig) {
    return LettersApiFp(this.configuration)
      .letterCancel(ltrId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Creates a new letter given information
   * @summary Create
   * @param {LetterEditable} letterEditable
   * @param {string} [idempotencyKey] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
   * @param {string} [idempotencyKey2] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LettersApi
   */
  public letterCreate(
    letterEditable: LetterEditable,
    idempotencyKey?: string,
    idempotencyKey2?: string,
    options?: AxiosRequestConfig
  ) {
    return LettersApiFp(this.configuration)
      .letterCreate(letterEditable, idempotencyKey, idempotencyKey2, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Retrieves the details of an existing letter. You need only supply the unique letter identifier that was returned upon letter creation.
   * @summary Retrieve
   * @param {string} ltrId id of the letter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LettersApi
   */
  public letterRetrieve(ltrId: string, options?: AxiosRequestConfig) {
    return LettersApiFp(this.configuration)
      .letterRetrieve(ltrId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Returns a list of your letters. The letters are returned sorted by creation date, with the most recently created letters appearing first.
   * @summary List
   * @param {number} [limit] How many results to return.
   * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
   * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
   * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
   * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
   * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
   * @param {boolean} [color] Set to &#x60;true&#x60; to return only color letters. Set to &#x60;false&#x60; to return only black &amp; white letters.
   * @param {boolean} [scheduled] * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;
   * @param {SendDate} [sendDate] Filter by ISO-8601 date or datetime, e.g. &#x60;{ gt: \&#39;2012-01-01\&#39;, lt: \&#39;2012-01-31T12:34:56Z\&#39; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.
   * @param {MailType} [mailType] A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.
   * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LettersApi
   */
  public lettersList(
    limit?: number,
    before?: string,
    after?: string,
    include?: { [key: string]: string },
    dateCreated?: { [key: string]: string },
    metadata?: { [key: string]: string },
    color?: boolean,
    scheduled?: boolean,
    sendDate?: SendDate,
    mailType?: MailType,
    sortBy?: object,
    options?: AxiosRequestConfig
  ) {
    return LettersApiFp(this.configuration)
      .lettersList(
        limit,
        before,
        after,
        include,
        dateCreated,
        metadata,
        color,
        scheduled,
        sendDate,
        mailType,
        sortBy,
        options
      )
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }
}

/**
 * PostcardsApi - axios parameter creator
 * @export
 */
export const PostcardsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a new postcard given information
     * @summary Create
     * @param {PostcardEditable} postcardEditable
     * @param {string} [idempotencyKey] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {string} [idempotencyKey2] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postcardCreate: async (
      postcardEditable: PostcardEditable,
      idempotencyKey?: string,
      idempotencyKey2?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'postcardEditable' is not null or undefined
      assertParamExists("postcardCreate", "postcardEditable", postcardEditable);
      const localVarPath = `/postcards`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (idempotencyKey2 !== undefined) {
        localVarQueryParameter["idempotency_key"] = idempotencyKey2;
      }

      if (idempotencyKey !== undefined && idempotencyKey !== null) {
        localVarHeaderParameter["Idempotency-Key"] = String(idempotencyKey);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        postcardEditable,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Completely removes a postcard from production. This can only be done if the postcard has a `send_date` and the `send_date` has not yet passed. If the postcard is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @summary Cancel
     * @param {string} pscId id of the postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postcardDelete: async (
      pscId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pscId' is not null or undefined
      assertParamExists("postcardDelete", "pscId", pscId);
      const localVarPath = `/postcards/{psc_id}`.replace(
        `{${"psc_id"}}`,
        encodeURIComponent(String(pscId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of an existing postcard. You need only supply the unique customer identifier that was returned upon postcard creation.
     * @summary Retrieve
     * @param {string} pscId id of the postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postcardRetrieve: async (
      pscId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'pscId' is not null or undefined
      assertParamExists("postcardRetrieve", "pscId", pscId);
      const localVarPath = `/postcards/{psc_id}`.replace(
        `{${"psc_id"}}`,
        encodeURIComponent(String(pscId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of your postcards. The addresses are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {PostcardSize} [size] Specifies the size of the postcard. Only &#x60;4x6&#x60; postcards can be sent to international destinations.
     * @param {boolean} [scheduled] * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;
     * @param {SendDate} [sendDate] Filter by ISO-8601 date or datetime, e.g. &#x60;{ gt: \&#39;2012-01-01\&#39;, lt: \&#39;2012-01-31T12:34:56Z\&#39; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.
     * @param {MailType} [mailType] A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postcardsList: async (
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      size?: PostcardSize,
      scheduled?: boolean,
      sendDate?: SendDate,
      mailType?: MailType,
      sortBy?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/postcards`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (before !== undefined) {
        localVarQueryParameter["before"] = before;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (dateCreated !== undefined) {
        localVarQueryParameter["date_created"] = dateCreated;
      }

      if (metadata !== undefined) {
        localVarQueryParameter["metadata"] = metadata;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (scheduled !== undefined) {
        localVarQueryParameter["scheduled"] = scheduled;
      }

      if (sendDate !== undefined) {
        localVarQueryParameter["send_date"] = sendDate;
      }

      if (mailType !== undefined) {
        localVarQueryParameter["mail_type"] = mailType;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter["sort_by"] = sortBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PostcardsApi - functional programming interface
 * @export
 */
export const PostcardsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PostcardsApiAxiosParamCreator(configuration);
  return {
    /**
     * Creates a new postcard given information
     * @summary Create
     * @param {PostcardEditable} postcardEditable
     * @param {string} [idempotencyKey] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {string} [idempotencyKey2] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postcardCreate(
      postcardEditable: PostcardEditable,
      idempotencyKey?: string,
      idempotencyKey2?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Postcard>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postcardCreate(
        postcardEditable,
        idempotencyKey,
        idempotencyKey2,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Completely removes a postcard from production. This can only be done if the postcard has a `send_date` and the `send_date` has not yet passed. If the postcard is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @summary Cancel
     * @param {string} pscId id of the postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postcardDelete(
      pscId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PostcardDeletion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postcardDelete(
        pscId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves the details of an existing postcard. You need only supply the unique customer identifier that was returned upon postcard creation.
     * @summary Retrieve
     * @param {string} pscId id of the postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postcardRetrieve(
      pscId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Postcard>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postcardRetrieve(pscId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of your postcards. The addresses are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {PostcardSize} [size] Specifies the size of the postcard. Only &#x60;4x6&#x60; postcards can be sent to international destinations.
     * @param {boolean} [scheduled] * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;
     * @param {SendDate} [sendDate] Filter by ISO-8601 date or datetime, e.g. &#x60;{ gt: \&#39;2012-01-01\&#39;, lt: \&#39;2012-01-31T12:34:56Z\&#39; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.
     * @param {MailType} [mailType] A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postcardsList(
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      size?: PostcardSize,
      scheduled?: boolean,
      sendDate?: SendDate,
      mailType?: MailType,
      sortBy?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostcardList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postcardsList(
        limit,
        before,
        after,
        include,
        dateCreated,
        metadata,
        size,
        scheduled,
        sendDate,
        mailType,
        sortBy,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PostcardsApi - factory interface
 * @export
 */
export const PostcardsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PostcardsApiFp(configuration);
  return {
    /**
     * Creates a new postcard given information
     * @summary Create
     * @param {PostcardEditable} postcardEditable
     * @param {string} [idempotencyKey] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {string} [idempotencyKey2] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postcardCreate(
      postcardEditable: PostcardEditable,
      idempotencyKey?: string,
      idempotencyKey2?: string,
      options?: any
    ): AxiosPromise<Postcard> {
      return localVarFp
        .postcardCreate(
          postcardEditable,
          idempotencyKey,
          idempotencyKey2,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Completely removes a postcard from production. This can only be done if the postcard has a `send_date` and the `send_date` has not yet passed. If the postcard is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
     * @summary Cancel
     * @param {string} pscId id of the postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postcardDelete(
      pscId: string,
      options?: any
    ): AxiosPromise<PostcardDeletion> {
      return localVarFp
        .postcardDelete(pscId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of an existing postcard. You need only supply the unique customer identifier that was returned upon postcard creation.
     * @summary Retrieve
     * @param {string} pscId id of the postcard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postcardRetrieve(pscId: string, options?: any): AxiosPromise<Postcard> {
      return localVarFp
        .postcardRetrieve(pscId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of your postcards. The addresses are returned sorted by creation date, with the most recently created addresses appearing first.
     * @summary List
     * @param {number} [limit] How many results to return.
     * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
     * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
     * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
     * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
     * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
     * @param {PostcardSize} [size] Specifies the size of the postcard. Only &#x60;4x6&#x60; postcards can be sent to international destinations.
     * @param {boolean} [scheduled] * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;
     * @param {SendDate} [sendDate] Filter by ISO-8601 date or datetime, e.g. &#x60;{ gt: \&#39;2012-01-01\&#39;, lt: \&#39;2012-01-31T12:34:56Z\&#39; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.
     * @param {MailType} [mailType] A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.
     * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postcardsList(
      limit?: number,
      before?: string,
      after?: string,
      include?: { [key: string]: string },
      dateCreated?: { [key: string]: string },
      metadata?: { [key: string]: string },
      size?: PostcardSize,
      scheduled?: boolean,
      sendDate?: SendDate,
      mailType?: MailType,
      sortBy?: object,
      options?: any
    ): AxiosPromise<PostcardList> {
      return localVarFp
        .postcardsList(
          limit,
          before,
          after,
          include,
          dateCreated,
          metadata,
          size,
          scheduled,
          sendDate,
          mailType,
          sortBy,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PostcardsApi - object-oriented interface
 * @export
 * @class PostcardsApi
 * @extends {BaseAPI}
 */
export class PostcardsApi extends BaseAPI {
  /**
   * Creates a new postcard given information
   * @summary Create
   * @param {PostcardEditable} postcardEditable
   * @param {string} [idempotencyKey] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
   * @param {string} [idempotencyKey2] A string of no longer than 256 characters that uniquely identifies this resource. For more help integrating idempotency keys, refer to our [implementation guide](https://www.lob.com/guides#idempotent_request).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostcardsApi
   */
  public postcardCreate(
    postcardEditable: PostcardEditable,
    idempotencyKey?: string,
    idempotencyKey2?: string,
    options?: AxiosRequestConfig
  ) {
    return PostcardsApiFp(this.configuration)
      .postcardCreate(
        postcardEditable,
        idempotencyKey,
        idempotencyKey2,
        options
      )
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Completely removes a postcard from production. This can only be done if the postcard has a `send_date` and the `send_date` has not yet passed. If the postcard is successfully canceled, you will not be charged for it. Read more on [cancellation windows](#section/Cancellation-Windows) and [scheduling](#section/Scheduled-Mailings). Scheduling and cancellation is a premium feature. Upgrade to the appropriate [Print & Mail Edition](https://dashboard.lob.com/#/settings/editions) to gain access.
   * @summary Cancel
   * @param {string} pscId id of the postcard
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostcardsApi
   */
  public postcardDelete(pscId: string, options?: AxiosRequestConfig) {
    return PostcardsApiFp(this.configuration)
      .postcardDelete(pscId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Retrieves the details of an existing postcard. You need only supply the unique customer identifier that was returned upon postcard creation.
   * @summary Retrieve
   * @param {string} pscId id of the postcard
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostcardsApi
   */
  public postcardRetrieve(pscId: string, options?: AxiosRequestConfig) {
    return PostcardsApiFp(this.configuration)
      .postcardRetrieve(pscId, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }

  /**
   * Returns a list of your postcards. The addresses are returned sorted by creation date, with the most recently created addresses appearing first.
   * @summary List
   * @param {number} [limit] How many results to return.
   * @param {string} [before] A reference to a list entry used for paginating to the previous set of entries. This field is pre-populated in the &#x60;previous_url&#x60; field in the return response.
   * @param {string} [after] A reference to a list entry used for paginating to the next set of entries. This field is pre-populated in the &#x60;next_url&#x60; field in the return response.
   * @param {{ [key: string]: string; }} [include] Request that the response include the total count by specifying &#x60;include[]&#x3D;total_count&#x60;.
   * @param {{ [key: string]: string; }} [dateCreated] Filter by date created.
   * @param {{ [key: string]: string; }} [metadata] Filter by metadata key-value pair&#x60;.
   * @param {PostcardSize} [size] Specifies the size of the postcard. Only &#x60;4x6&#x60; postcards can be sent to international destinations.
   * @param {boolean} [scheduled] * &#x60;true&#x60; - only return orders (past or future) where &#x60;send_date&#x60; is greater than &#x60;date_created&#x60; * &#x60;false&#x60; - only return orders where &#x60;send_date&#x60; is equal to &#x60;date_created&#x60;
   * @param {SendDate} [sendDate] Filter by ISO-8601 date or datetime, e.g. &#x60;{ gt: \&#39;2012-01-01\&#39;, lt: \&#39;2012-01-31T12:34:56Z\&#39; }&#x60; where &#x60;gt&#x60; is &gt;, &#x60;lt&#x60; is &lt;, &#x60;gte&#x60; is ≥, and &#x60;lte&#x60; is ≤.
   * @param {MailType} [mailType] A string designating the mail postage type: * &#x60;usps_first_class&#x60; - (default) * &#x60;usps_standard&#x60; - a [cheaper option](https://lob.com/pricing/print-mail#compare) which is less predictable and takes longer to deliver. &#x60;usps_standard&#x60; cannot be used with &#x60;4x6&#x60; postcards or for any postcards sent outside of the United States.
   * @param {object} [sortBy] Sorts items by ascending or descending dates. Use either &#x60;date_created&#x60; or &#x60;send_date&#x60;, not both.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PostcardsApi
   */
  public postcardsList(
    limit?: number,
    before?: string,
    after?: string,
    include?: { [key: string]: string },
    dateCreated?: { [key: string]: string },
    metadata?: { [key: string]: string },
    size?: PostcardSize,
    scheduled?: boolean,
    sendDate?: SendDate,
    mailType?: MailType,
    sortBy?: object,
    options?: AxiosRequestConfig
  ) {
    return PostcardsApiFp(this.configuration)
      .postcardsList(
        limit,
        before,
        after,
        include,
        dateCreated,
        metadata,
        size,
        scheduled,
        sendDate,
        mailType,
        sortBy,
        options
      )
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }
}

/**
 * USVerificationsApi - axios parameter creator
 * @export
 */
export const USVerificationsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Verify a US or US territory address _with a live API key_. The address can be in components (e.g. `primary_line` is \"210 King Street\", `zip_code` is \"94107\") or as a single string (e.g. \"210 King Street 94107\"), but not as both. Requests using a test API key validate required fields but return empty values unless specific `primary_line` values are provided. See the [US Verifications Test Environment](#section/US-Verifications-Test-Env) for details.
     * @summary Single Verify
     * @param {UsVerificationsWritable} usVerificationsWritable
     * @param {'upper' | 'proper'} [_case] Casing of the verified address. Possible values are &#x60;upper&#x60; and &#x60;proper&#x60; for uppercased (e.g. \&quot;PO BOX\&quot;) and proper-cased (e.g. \&quot;PO Box\&quot;), respectively. Only affects &#x60;recipient&#x60;, &#x60;primary_line&#x60;, &#x60;secondary_line&#x60;, &#x60;urbanization&#x60;, and &#x60;last_line&#x60;. Default casing is &#x60;upper&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usVerification: async (
      usVerificationsWritable: UsVerificationsWritable,
      _case?: "upper" | "proper",
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'usVerificationsWritable' is not null or undefined
      assertParamExists(
        "usVerification",
        "usVerificationsWritable",
        usVerificationsWritable
      );
      const localVarPath = `/us_verifications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicAuth required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (_case !== undefined) {
        localVarQueryParameter["case"] = _case;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        usVerificationsWritable,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * USVerificationsApi - functional programming interface
 * @export
 */
export const USVerificationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    USVerificationsApiAxiosParamCreator(configuration);
  return {
    /**
     * Verify a US or US territory address _with a live API key_. The address can be in components (e.g. `primary_line` is \"210 King Street\", `zip_code` is \"94107\") or as a single string (e.g. \"210 King Street 94107\"), but not as both. Requests using a test API key validate required fields but return empty values unless specific `primary_line` values are provided. See the [US Verifications Test Environment](#section/US-Verifications-Test-Env) for details.
     * @summary Single Verify
     * @param {UsVerificationsWritable} usVerificationsWritable
     * @param {'upper' | 'proper'} [_case] Casing of the verified address. Possible values are &#x60;upper&#x60; and &#x60;proper&#x60; for uppercased (e.g. \&quot;PO BOX\&quot;) and proper-cased (e.g. \&quot;PO Box\&quot;), respectively. Only affects &#x60;recipient&#x60;, &#x60;primary_line&#x60;, &#x60;secondary_line&#x60;, &#x60;urbanization&#x60;, and &#x60;last_line&#x60;. Default casing is &#x60;upper&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async usVerification(
      usVerificationsWritable: UsVerificationsWritable,
      _case?: "upper" | "proper",
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsVerification>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.usVerification(
        usVerificationsWritable,
        _case,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * USVerificationsApi - factory interface
 * @export
 */
export const USVerificationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = USVerificationsApiFp(configuration);
  return {
    /**
     * Verify a US or US territory address _with a live API key_. The address can be in components (e.g. `primary_line` is \"210 King Street\", `zip_code` is \"94107\") or as a single string (e.g. \"210 King Street 94107\"), but not as both. Requests using a test API key validate required fields but return empty values unless specific `primary_line` values are provided. See the [US Verifications Test Environment](#section/US-Verifications-Test-Env) for details.
     * @summary Single Verify
     * @param {UsVerificationsWritable} usVerificationsWritable
     * @param {'upper' | 'proper'} [_case] Casing of the verified address. Possible values are &#x60;upper&#x60; and &#x60;proper&#x60; for uppercased (e.g. \&quot;PO BOX\&quot;) and proper-cased (e.g. \&quot;PO Box\&quot;), respectively. Only affects &#x60;recipient&#x60;, &#x60;primary_line&#x60;, &#x60;secondary_line&#x60;, &#x60;urbanization&#x60;, and &#x60;last_line&#x60;. Default casing is &#x60;upper&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    usVerification(
      usVerificationsWritable: UsVerificationsWritable,
      _case?: "upper" | "proper",
      options?: any
    ): AxiosPromise<UsVerification> {
      return localVarFp
        .usVerification(usVerificationsWritable, _case, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * USVerificationsApi - object-oriented interface
 * @export
 * @class USVerificationsApi
 * @extends {BaseAPI}
 */
export class USVerificationsApi extends BaseAPI {
  /**
   * Verify a US or US territory address _with a live API key_. The address can be in components (e.g. `primary_line` is \"210 King Street\", `zip_code` is \"94107\") or as a single string (e.g. \"210 King Street 94107\"), but not as both. Requests using a test API key validate required fields but return empty values unless specific `primary_line` values are provided. See the [US Verifications Test Environment](#section/US-Verifications-Test-Env) for details.
   * @summary Single Verify
   * @param {UsVerificationsWritable} usVerificationsWritable
   * @param {'upper' | 'proper'} [_case] Casing of the verified address. Possible values are &#x60;upper&#x60; and &#x60;proper&#x60; for uppercased (e.g. \&quot;PO BOX\&quot;) and proper-cased (e.g. \&quot;PO Box\&quot;), respectively. Only affects &#x60;recipient&#x60;, &#x60;primary_line&#x60;, &#x60;secondary_line&#x60;, &#x60;urbanization&#x60;, and &#x60;last_line&#x60;. Default casing is &#x60;upper&#x60;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof USVerificationsApi
   */
  public usVerification(
    usVerificationsWritable: UsVerificationsWritable,
    _case?: "upper" | "proper",
    options?: AxiosRequestConfig
  ) {
    return USVerificationsApiFp(this.configuration)
      .usVerification(usVerificationsWritable, _case, options)
      .then((request) => request(this.axios, this.basePath))
      .then(function (response) {
        return response.data;
      })
      .catch((error) => {
        if (error.response) {
          console.log(error.response.data);
          return error;
        }
      });
  }
}
